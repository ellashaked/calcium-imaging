{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sekler Calcium Imaging","text":"<p>Easily analyze VSI outputs.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>calcium_imaging<ul> <li>analysis<ul> <li>baseline_return_detection</li> <li>eflux_calculation</li> <li>influx_calculation</li> <li>linear_fit</li> <li>onset_detection</li> <li>peak_detection</li> <li>regression_coefficients</li> </ul> </li> <li>data_models<ul> <li>coverslip</li> <li>experiment</li> <li>group</li> <li>research</li> <li>roi</li> </ul> </li> <li>instantiation</li> <li>io<ul> <li>load_vsi</li> <li>validate_experiment_dir</li> </ul> </li> <li>processing<ul> <li>constants</li> <li>extract_coverslip_info_from_filename</li> <li>extract_roi_id_from_col_name</li> <li>preprocessor</li> </ul> </li> <li>ui<ul> <li>get_bool_input</li> <li>get_int_input</li> </ul> </li> <li>viz<ul> <li>create_trace_figure</li> <li>plotly_color_iterator</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/calcium_imaging/","title":"calcium_imaging","text":""},{"location":"reference/calcium_imaging/#calcium_imaging","title":"<code>calcium_imaging</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip","title":"<code>Coverslip</code>","text":"<p>One plate</p> Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>class Coverslip:\n    \"\"\"One plate\"\"\"\n\n    def __init__(self, coverslip_id: int, group_type: str, rois: List[ROI]) -&gt; None:\n        self.rois = self._init_rois(rois)\n        self._id2roi = {roi.roi_id: roi for roi in self.rois}\n        self.id = coverslip_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.id}\"\n        self.title = f\"Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})\"\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, roi_id: int) -&gt; ROI:\n        return self._id2roi[roi_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.rois)\n\n    def __iter__(self) -&gt; Iterator[ROI]:\n        return iter(self.rois)\n\n    def drop_roi(self, roi_id: int) -&gt; None:\n        try:\n            self._id2roi.pop(roi_id)\n            self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n            print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n        except KeyError:\n            print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([roi.trace for roi in self.rois], axis=1)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for roi in self.rois]\n        rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n        rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"Coverslip {self.id} ({self.group_type})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n        mean_trace.name = f\"Coverslip {self.id} mean\"\n        return mean_trace\n\n    def _calculate_metric(\n            self,\n            metric_calculation_func: Callable[['ROI'], float],\n            metric_name: str,\n    ) -&gt; Union[List[float], List[Dict[str, float]]]:\n        return [\n            {\n                \"group_type\": self.group_type,\n                \"coverslip\": roi.coverslip_id,\n                \"roi\": roi.roi_id,\n                metric_name: metric_calculation_func(roi)\n            }\n            for roi in self.rois\n        ]\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_eflux(),\n            metric_name=\"eflux\",\n        )\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_amplitude(),\n            metric_name=\"amplitude\",\n        )\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_integral(),\n            metric_name=\"integral\",\n        )\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_tau(),\n            metric_name=\"tau\",\n        )\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n            print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n        for roi in self.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_rois(rois: List[ROI]) -&gt; List[ROI]:\n        rois = sorted(rois, key=lambda roi: roi.roi_id)\n        if len(rois) == 0:\n            raise ValueError(f\"Initializing class Coverslip with empty ROIs list is illegal.\")\n        if not all([roi.coverslip_id == rois[0].coverslip_id for roi in rois]):\n            raise ValueError(f\"All ROIs must share the same coverslip ID.\")\n        return rois\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.group_type","title":"<code>group_type = group_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.id","title":"<code>id = coverslip_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.name","title":"<code>name = f'cs-{self.id}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.rois","title":"<code>rois = self._init_rois(rois)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.title","title":"<code>title = f'Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.align_onsets","title":"<code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n        print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n    for roi in self.rois:\n        roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_amplitude(),\n        metric_name=\"amplitude\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_eflux(),\n        metric_name=\"eflux\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_integral(),\n        metric_name=\"integral\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_tau(),\n        metric_name=\"tau\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.drop_roi","title":"<code>drop_roi(roi_id: int) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def drop_roi(self, roi_id: int) -&gt; None:\n    try:\n        self._id2roi.pop(roi_id)\n        self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n        print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n    except KeyError:\n        print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.get_df","title":"<code>get_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([roi.trace for roi in self.rois], axis=1)\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.get_mean_trace","title":"<code>get_mean_trace() -&gt; pd.Series</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n    mean_trace.name = f\"Coverslip {self.id} mean\"\n    return mean_trace\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Coverslip.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for roi in self.rois]\n    rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n    rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"Coverslip {self.id} ({self.group_type})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.CoverslipInfo","title":"<code>CoverslipInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>class CoverslipInfo(NamedTuple):\n    coverslip_id: int\n    group_type: str\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.CoverslipInfo-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.CoverslipInfo.coverslip_id","title":"<code>coverslip_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.CoverslipInfo.group_type","title":"<code>group_type: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment","title":"<code>Experiment</code>","text":"<p>A folder containing multiple Conditions, e.g., 'SI_SH_check'.</p> Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>class Experiment:\n    \"\"\"A folder containing multiple Conditions, e.g., 'SI_SH_check'.\"\"\"\n\n    def __init__(self, name: str, groups: List[Group]) -&gt; None:\n        \"\"\"Holds multiple groups of the same experiment.\"\"\"\n        self.name = name\n        self.groups = sorted(groups, key=lambda g: g.group_type)\n        self._id2group = {g.group_type: g for g in self.groups}\n        self.num_groups = len(self.groups)\n        self.num_rois = len([roi for roi in self.iter_rois()])\n        self.title = f\"{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})\"\n\n    def __getitem__(self, group_type: str) -&gt; Group:\n        return self._id2group[group_type]\n\n    def __len__(self) -&gt; int:\n        return len(self.groups)\n\n    def __iter__(self) -&gt; Iterator[Group]:\n        return iter(self.groups)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def visualize(self) -&gt; None:\n        colors = get_n_colors_from_palette(self.num_groups)\n\n        all_traces = []\n        max_trace_val = 0\n        for color, group in zip(colors, self.groups):\n            rois_traces = [roi.trace for cs in group for roi in cs]\n            average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n            average_trace.name = f\"{group.group_type} mean\"\n            if average_trace.max() &gt; max_trace_val:\n                max_trace_val = average_trace.max()\n            group_fig = create_traces_figure(\n                main_trace=average_trace,\n                traces_color=color\n            )\n            all_traces.append(group_fig.data[0])\n\n        # Combine all traces into one figure\n        fig = go.Figure(data=all_traces)\n        fig.update_layout(\n            title=self.name,\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            xaxis=dict(showgrid=False),\n            yaxis=dict(showgrid=False),\n            template=\"plotly_white\",\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=1,\n                xanchor=\"left\",\n                x=1.05,\n                font=dict(size=10),\n                traceorder=\"normal\",\n            ),\n        )\n        fig.show()\n\n    def align_onsets(self) -&gt; None:\n        print(\"aligning onsets within each group\")\n        target_onsets = [group.align_onsets() for group in self.groups]\n        target_onset_idx = int(np.median(target_onsets))\n\n        print(f\"aligning onsets across groups to {target_onset_idx}\")\n        for group in self.groups:\n            group.align_onsets(target_onset_idx)\n\n    def get_mean_traces_df(self) -&gt; pd.DataFrame:\n        mean_traces = [group.get_mean_trace() for group in self.groups]\n        df = pd.concat(mean_traces, axis=1)\n        return df\n\n    def visualize_all_rois(self) -&gt; None:\n        for roi in self.iter_rois():\n            try:\n                roi.visualize()\n            except Exception as e:\n                print(e)\n                print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n\n    def run_manual_analysis(self) -&gt; None:\n        for i, roi in enumerate(self.iter_rois()):\n            try:\n                print(f\"ROI {i}/{self.num_rois}\")\n                self._ask_to_update_params(roi)\n            except Exception as e:\n                print(e)\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n                drop = get_bool_input(\"drop ROI? (y/n): \")\n                if drop:\n                    msg = f\"deleted {roi.title}\"\n                    del roi\n                    print(msg)\n                else:\n                    self._ask_to_update_params(roi)\n\n    @staticmethod\n    def _ask_to_update_params(roi: ROI):\n        while True:\n            roi.visualize()\n            peak_idx = get_int_input(f\"peak_idx={roi.peak_idx}, enter to accept or input to edit: \")\n            if peak_idx is not None:\n                roi.set_peak_idx(peak_idx)\n\n            onset_idx = get_int_input(f\"onset_idx={roi.onset_idx}, enter to accept or input to edit: \")\n            if onset_idx is not None:\n                roi.set_onset_idx(onset_idx)\n\n            if peak_idx is not None or onset_idx is not None:\n                roi.visualize()\n            else:\n                break\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for group in self.groups\n            for eflux_rate in group.calculate_eflux_rates()\n        ]\n\n    def _get_eflux_rates_df(self) -&gt; pd.DataFrame:\n        records = self.calculate_eflux_rates()\n        df = pd.DataFrame.from_records(records)\n        cols = df.columns.tolist()\n        df[\"experiment_name\"] = self.name\n        new_cols_order = [\"experiment_name\"] + cols\n        df = df[new_cols_order]\n        df = df.sort_values(by=[\"coverslip\", \"roi\"], ascending=True)\n        return df\n\n    def visualize_eflux_bar_chart(self) -&gt; None:\n        df = self._get_eflux_rates_df()\n        group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n        # Compute SEM and 95% CI (approx)\n        group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n        group_stats['ci95'] = 1.96 * group_stats['sem']\n\n        # Plot with 95% CI as error bars\n        fig = go.Figure([\n            go.Bar(\n                x=group_stats.index,\n                y=group_stats['mean'],\n                error_y=dict(type='data', array=group_stats['ci95']),\n                name='Mean \u00b1 95% CI'\n            )\n        ])\n        fig.update_layout(\n            title=\"Eflux mean with 95% Confidence Interval\",\n            xaxis_title=\"Group Type\",\n            yaxis_title=\"Eflux\",\n            template=\"plotly_white\"\n        )\n        fig.show()\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for group in self.groups\n            for amplitude in group.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for group in self.groups\n            for integral in group.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for group in self.groups\n            for tau in group.calculate_taus()\n        ]\n\n    def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n        return {g.group_type: g.get_df() for g in self.groups}\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n        for group_type, df in self.get_group_type_to_df().items():\n            base = results_output_dir_path / group_type\n            df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n            df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n\n    def iter_rois(self) -&gt; Iterator[ROI]:\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    yield roi\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        records = []\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    try:\n                        eflux = roi.calculate_eflux()\n                    except RuntimeError:\n                        eflux = np.nan\n\n                    try:\n                        influx = roi.calculate_influx()\n                    except RuntimeError:\n                        influx = np.nan\n\n                    try:\n                        amplitude = roi.calculate_amplitude()\n                    except RuntimeError:\n                        amplitude = np.nan\n\n                    try:\n                        integral = roi.calculate_integral()\n                    except RuntimeError:\n                        integral = np.nan\n\n                    try:\n                        tau = roi.calculate_tau()\n                    except RuntimeError:\n                        tau = np.nan\n\n                    records.append({\n                        \"experiment_name\": self.name,\n                        \"group_type\": group.group_type,\n                        \"coverslip\": coverslip.id,\n                        \"roi\": roi.roi_id,\n                        \"onset_frame\": roi.onset_idx,\n                        \"peak_frame\": roi.peak_idx,\n                        \"eflux\": eflux,\n                        \"influx\": influx,\n                        \"amplitude\": amplitude,\n                        \"integral\": integral,\n                        \"tau\": tau,\n                    })\n\n        df = pd.DataFrame.from_records(records)\n        df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.groups","title":"<code>groups = sorted(groups, key=lambda g: g.group_type)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.num_groups","title":"<code>num_groups = len(self.groups)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.num_rois","title":"<code>num_rois = len([roi for roi in self.iter_rois()])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.title","title":"<code>title = f'{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.align_onsets","title":"<code>align_onsets() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def align_onsets(self) -&gt; None:\n    print(\"aligning onsets within each group\")\n    target_onsets = [group.align_onsets() for group in self.groups]\n    target_onset_idx = int(np.median(target_onsets))\n\n    print(f\"aligning onsets across groups to {target_onset_idx}\")\n    for group in self.groups:\n        group.align_onsets(target_onset_idx)\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for group in self.groups\n        for amplitude in group.calculate_amplitudes()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for group in self.groups\n        for eflux_rate in group.calculate_eflux_rates()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for group in self.groups\n        for integral in group.calculate_integrals()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for group in self.groups\n        for tau in group.calculate_taus()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.get_full_analysis_df","title":"<code>get_full_analysis_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    records = []\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                try:\n                    eflux = roi.calculate_eflux()\n                except RuntimeError:\n                    eflux = np.nan\n\n                try:\n                    influx = roi.calculate_influx()\n                except RuntimeError:\n                    influx = np.nan\n\n                try:\n                    amplitude = roi.calculate_amplitude()\n                except RuntimeError:\n                    amplitude = np.nan\n\n                try:\n                    integral = roi.calculate_integral()\n                except RuntimeError:\n                    integral = np.nan\n\n                try:\n                    tau = roi.calculate_tau()\n                except RuntimeError:\n                    tau = np.nan\n\n                records.append({\n                    \"experiment_name\": self.name,\n                    \"group_type\": group.group_type,\n                    \"coverslip\": coverslip.id,\n                    \"roi\": roi.roi_id,\n                    \"onset_frame\": roi.onset_idx,\n                    \"peak_frame\": roi.peak_idx,\n                    \"eflux\": eflux,\n                    \"influx\": influx,\n                    \"amplitude\": amplitude,\n                    \"integral\": integral,\n                    \"tau\": tau,\n                })\n\n    df = pd.DataFrame.from_records(records)\n    df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.get_group_type_to_df","title":"<code>get_group_type_to_df() -&gt; Dict[str, pd.DataFrame]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n    return {g.group_type: g.get_df() for g in self.groups}\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.get_mean_traces_df","title":"<code>get_mean_traces_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_mean_traces_df(self) -&gt; pd.DataFrame:\n    mean_traces = [group.get_mean_trace() for group in self.groups]\n    df = pd.concat(mean_traces, axis=1)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.iter_rois","title":"<code>iter_rois() -&gt; Iterator[ROI]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def iter_rois(self) -&gt; Iterator[ROI]:\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                yield roi\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.run_manual_analysis","title":"<code>run_manual_analysis() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def run_manual_analysis(self) -&gt; None:\n    for i, roi in enumerate(self.iter_rois()):\n        try:\n            print(f\"ROI {i}/{self.num_rois}\")\n            self._ask_to_update_params(roi)\n        except Exception as e:\n            print(e)\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n            drop = get_bool_input(\"drop ROI? (y/n): \")\n            if drop:\n                msg = f\"deleted {roi.title}\"\n                del roi\n                print(msg)\n            else:\n                self._ask_to_update_params(roi)\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.save_mega_dfs","title":"<code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n    for group_type, df in self.get_group_type_to_df().items():\n        base = results_output_dir_path / group_type\n        df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.visualize","title":"<code>visualize() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize(self) -&gt; None:\n    colors = get_n_colors_from_palette(self.num_groups)\n\n    all_traces = []\n    max_trace_val = 0\n    for color, group in zip(colors, self.groups):\n        rois_traces = [roi.trace for cs in group for roi in cs]\n        average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n        average_trace.name = f\"{group.group_type} mean\"\n        if average_trace.max() &gt; max_trace_val:\n            max_trace_val = average_trace.max()\n        group_fig = create_traces_figure(\n            main_trace=average_trace,\n            traces_color=color\n        )\n        all_traces.append(group_fig.data[0])\n\n    # Combine all traces into one figure\n    fig = go.Figure(data=all_traces)\n    fig.update_layout(\n        title=self.name,\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        template=\"plotly_white\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n    fig.show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.visualize_all_rois","title":"<code>visualize_all_rois() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_all_rois(self) -&gt; None:\n    for roi in self.iter_rois():\n        try:\n            roi.visualize()\n        except Exception as e:\n            print(e)\n            print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Experiment.visualize_eflux_bar_chart","title":"<code>visualize_eflux_bar_chart() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_eflux_bar_chart(self) -&gt; None:\n    df = self._get_eflux_rates_df()\n    group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n    # Compute SEM and 95% CI (approx)\n    group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n    group_stats['ci95'] = 1.96 * group_stats['sem']\n\n    # Plot with 95% CI as error bars\n    fig = go.Figure([\n        go.Bar(\n            x=group_stats.index,\n            y=group_stats['mean'],\n            error_y=dict(type='data', array=group_stats['ci95']),\n            name='Mean \u00b1 95% CI'\n        )\n    ])\n    fig.update_layout(\n        title=\"Eflux mean with 95% Confidence Interval\",\n        xaxis_title=\"Group Type\",\n        yaxis_title=\"Eflux\",\n        template=\"plotly_white\"\n    )\n    fig.show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group","title":"<code>Group</code>","text":"<p>One group with certain intervention, e.g. 'shNCLX'.</p> Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>class Group:\n    \"\"\"One group with certain intervention, e.g. 'shNCLX'.\"\"\"\n\n    def __init__(self, coverslips: List[Coverslip]) -&gt; None:\n        \"\"\"Holds multiple runs of the same group\"\"\"\n        self.coverslips = self._init_coverslips(coverslips)\n        self._id2coverslip = {cs.id: cs for cs in self.coverslips}\n        self.group_type = self._infer_group_type()\n        self.title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, coverslip_id: int) -&gt; Coverslip:\n        return self._id2coverslip[coverslip_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.coverslips)\n\n    def __iter__(self) -&gt; Iterator[Coverslip]:\n        return iter(self.coverslips)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n        rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n        rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n        mean_trace.name = f\"{self.group_type} mean\"\n        return mean_trace\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for cs in self.coverslips\n            for eflux_rate in cs.calculate_eflux_rates()\n        ]\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for cs in self.coverslips\n            for amplitude in cs.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for cs in self.coverslips\n            for integral in cs.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for cs in self.coverslips\n            for tau in cs.calculate_taus()\n        ]\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n            target_onset_idx = int(np.median(onset_indexes))\n            print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n        for coverslip in self.coverslips:\n            for roi in coverslip.rois:\n                roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_coverslips(coverslips: List[Coverslip]) -&gt; List[Coverslip]:\n        coverslips = sorted(coverslips, key=lambda cs: cs.id)\n        if len(coverslips) == 0:\n            raise ValueError(f\"Initializing class Group with empty Coverslips list is illegal.\")\n        if not all([cs.group_type == coverslips[0].group_type for cs in coverslips]):\n            raise ValueError(f\"All Coverslips must share the same group type.\")\n        return coverslips\n\n    def _infer_group_type(self) -&gt; str:\n        return self.coverslips[0].group_type\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Group.coverslips","title":"<code>coverslips = self._init_coverslips(coverslips)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Group.group_type","title":"<code>group_type = self._infer_group_type()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Group.title","title":"<code>title = f'{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Group-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Group.align_onsets","title":"<code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        target_onset_idx = int(np.median(onset_indexes))\n        print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n    for coverslip in self.coverslips:\n        for roi in coverslip.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for cs in self.coverslips\n        for amplitude in cs.calculate_amplitudes()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for cs in self.coverslips\n        for eflux_rate in cs.calculate_eflux_rates()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for cs in self.coverslips\n        for integral in cs.calculate_integrals()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for cs in self.coverslips\n        for tau in cs.calculate_taus()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.get_df","title":"<code>get_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.get_mean_trace","title":"<code>get_mean_trace() -&gt; pd.Series</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n    mean_trace.name = f\"{self.group_type} mean\"\n    return mean_trace\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Group.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n    rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n    rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor","title":"<code>Preprocessor</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>class Preprocessor:\n    def __init__(\n            self,\n            first_n_points_to_discard: int = 5,\n            smoothing_windows_size: int = 2,\n            time_col_name: str = TIME_COL,\n            background_fluorescence_cols_names: List[str] = BACKGROUND_FLUORESCENCE_ROIS,\n            normalization_sampling_start_frame: int = 1,\n            normalization_sampling_end_frame: int = 35,\n            earliest_onset_frame: int = 50,\n            earliest_baseline_recovery_frame: int = 90,\n            drop_traces_with_corrupted_peak: bool = False,\n            drop_background_fluorescence_cols: bool = True\n    ) -&gt; None:\n        self.first_n_points_to_discard = first_n_points_to_discard\n        self.smoothing_windows_size = smoothing_windows_size\n        self.time_col_name = time_col_name\n        self.background_fluorescence_cols_names = background_fluorescence_cols_names\n        self.normalization_sampling_start_frame = normalization_sampling_start_frame\n        self.normalization_sampling_end_frame = normalization_sampling_end_frame\n        self.earliest_onset_frame = earliest_onset_frame\n        self.earliest_baseline_recovery_frame = earliest_baseline_recovery_frame\n        self.drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak\n        self.drop_background_fluorescence_cols = drop_background_fluorescence_cols\n\n    def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        df = df.copy(deep=True)\n        df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n        df = self.smoothen(df, window_size=self.smoothing_windows_size)\n        df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n        if self.drop_background_fluorescence_cols:\n            df = df.drop(columns=self.background_fluorescence_cols_names)\n        df = self.normalize(\n            df=df,\n            sampling_start_frame=self.normalization_sampling_start_frame,\n            sampling_end_frame=self.normalization_sampling_end_frame\n        )\n        df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n        return df\n\n    @staticmethod\n    def discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n        return df.iloc[n:]\n\n    @staticmethod\n    def smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        return df.rolling(\n            window=window_size,\n            min_periods=1,  # allow smaller windows at edges\n            center=True\n        ).mean()\n\n    @staticmethod\n    def subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n        averaged = df[background_roi_cols].mean(axis=1)\n        result_df = df.subtract(averaged, axis=0)\n        return result_df\n\n    @staticmethod\n    def normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n        result_df = df.div(f0, axis=1)\n        return result_df\n\n    @staticmethod\n    def reject_noise(\n            df: pd.DataFrame,\n            *,\n            start_index: int = 35,\n            factor_mean: float = 7.0,\n            factor_peak: float = 2.0,\n            overshoot_thresh: float = 2.0,\n            overshoot_repl: float = 3.0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Drop columns considered artifactual.\n\n        Criteria (mirrors original MATLAB logic):\n\n        1. Global peak occurs before the rising point  \u2192 remove column.\n        2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n        3. Overshoot spikes above threshold are *corrected* in-place\n           before criteria 1\u20132 are evaluated.\n\n        Returns\n        -------\n        pd.DataFrame\n            Cleaned dataframe with offending columns removed.\n        \"\"\"\n        cleaned = df.copy(deep=True)\n\n        for col in cleaned.columns:\n            s = cleaned[col]\n\n            # step-wise overshoot correction (in-place)\n            cleaned[col] = Preprocessor.correct_overshoot(\n                s,\n                factor_threshold=overshoot_thresh,\n                factor_replacement=overshoot_repl,\n            )\n\n            if Preprocessor.noisy_pre_rise(\n                    cleaned[col], factor_mean, factor_peak, start_index\n            ):\n                cleaned.drop(columns=[col], inplace=True)\n\n        return cleaned\n\n    # ------------------------------------------------------------------\n    def _detect_traces_with_corrupted_peak(self, df: pd.DataFrame, drop: bool = False) -&gt; pd.DataFrame:\n        \"\"\"True if the global maximum is located *before* `start_index`.\"\"\"\n        result_df = df.copy(deep=True)\n        for col, trace in df.items():\n            idx_max = trace.index.values[trace.argmax()]\n            if idx_max &lt; self.earliest_onset_frame:\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n                print(f\"   warning {col}: peak detected before frame {self.earliest_onset_frame}, drop={drop}\")\n            if idx_max &gt; self.earliest_baseline_recovery_frame:\n                print(f\"   warning {col}: peak detected after frame {self.earliest_baseline_recovery_frame}, drop={drop}\")\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n        return result_df\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def correct_overshoot(\n            trace: pd.Series,\n            factor_threshold: float,\n            factor_replacement: float,\n            pre_window: int = 35,\n    ) -&gt; pd.Series:\n        \"\"\"\n        Clamp samples whose value exceeds\n            smooth + factor_threshold * mean_pre_peaks\n        to\n            smooth + factor_replacement * mean_pre_peaks.\n\n        The moving-average of the trace (window=10) is used as the\n        \u201csmooth\u201d estimate.\n        \"\"\"\n        if trace.isna().all():\n            return trace\n\n        smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n        # peaks only in the pre-rise region\n        peaks, _ = find_peaks(trace.iloc[:pre_window])\n        mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n        threshold = smooth + factor_threshold * mean_pre_peaks\n        replacement = smooth + factor_replacement * mean_pre_peaks\n\n        corrected = trace.where(trace &lt;= threshold, replacement)\n        return corrected\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def noisy_pre_rise(\n            trace: pd.Series,\n            factor_mean: float,\n            factor_peak: float,\n            start_index: int = 35,\n    ) -&gt; bool:\n        \"\"\"\n        Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n        Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n        Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n        \"\"\"\n        if trace.isna().all():\n            return True\n\n        pre_segment = trace.iloc[:start_index]\n        peaks, _ = find_peaks(pre_segment)\n\n        if peaks.size == 0:\n            return False  # no peaks \u21d2 not noisy by this definition\n\n        peaks_vals = pre_segment.iloc[peaks]\n        global_max = trace.max()\n\n        condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n        condition2 = peaks_vals.max() * factor_peak &gt; global_max\n        return condition1 or condition2\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.background_fluorescence_cols_names","title":"<code>background_fluorescence_cols_names = background_fluorescence_cols_names</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.drop_background_fluorescence_cols","title":"<code>drop_background_fluorescence_cols = drop_background_fluorescence_cols</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.drop_traces_with_corrupted_peak","title":"<code>drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.earliest_baseline_recovery_frame","title":"<code>earliest_baseline_recovery_frame = earliest_baseline_recovery_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.earliest_onset_frame","title":"<code>earliest_onset_frame = earliest_onset_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.first_n_points_to_discard","title":"<code>first_n_points_to_discard = first_n_points_to_discard</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.normalization_sampling_end_frame","title":"<code>normalization_sampling_end_frame = normalization_sampling_end_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.normalization_sampling_start_frame","title":"<code>normalization_sampling_start_frame = normalization_sampling_start_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.smoothing_windows_size","title":"<code>smoothing_windows_size = smoothing_windows_size</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.time_col_name","title":"<code>time_col_name = time_col_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.correct_overshoot","title":"<code>correct_overshoot(trace: pd.Series, factor_threshold: float, factor_replacement: float, pre_window: int = 35) -&gt; pd.Series</code>  <code>staticmethod</code>","text":"<p>Clamp samples whose value exceeds     smooth + factor_threshold * mean_pre_peaks to     smooth + factor_replacement * mean_pre_peaks.</p> <p>The moving-average of the trace (window=10) is used as the \u201csmooth\u201d estimate.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef correct_overshoot(\n        trace: pd.Series,\n        factor_threshold: float,\n        factor_replacement: float,\n        pre_window: int = 35,\n) -&gt; pd.Series:\n    \"\"\"\n    Clamp samples whose value exceeds\n        smooth + factor_threshold * mean_pre_peaks\n    to\n        smooth + factor_replacement * mean_pre_peaks.\n\n    The moving-average of the trace (window=10) is used as the\n    \u201csmooth\u201d estimate.\n    \"\"\"\n    if trace.isna().all():\n        return trace\n\n    smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n    # peaks only in the pre-rise region\n    peaks, _ = find_peaks(trace.iloc[:pre_window])\n    mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n    threshold = smooth + factor_threshold * mean_pre_peaks\n    replacement = smooth + factor_replacement * mean_pre_peaks\n\n    corrected = trace.where(trace &lt;= threshold, replacement)\n    return corrected\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.discard_first_n_points","title":"<code>discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n    return df.iloc[n:]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.noisy_pre_rise","title":"<code>noisy_pre_rise(trace: pd.Series, factor_mean: float, factor_peak: float, start_index: int = 35) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Returns True if the pre-rise segment is noisy per MATLAB rules.</p> <p>Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef noisy_pre_rise(\n        trace: pd.Series,\n        factor_mean: float,\n        factor_peak: float,\n        start_index: int = 35,\n) -&gt; bool:\n    \"\"\"\n    Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n    Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n    Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n    \"\"\"\n    if trace.isna().all():\n        return True\n\n    pre_segment = trace.iloc[:start_index]\n    peaks, _ = find_peaks(pre_segment)\n\n    if peaks.size == 0:\n        return False  # no peaks \u21d2 not noisy by this definition\n\n    peaks_vals = pre_segment.iloc[peaks]\n    global_max = trace.max()\n\n    condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n    condition2 = peaks_vals.max() * factor_peak &gt; global_max\n    return condition1 or condition2\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.normalize","title":"<code>normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n    result_df = df.div(f0, axis=1)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.preprocess","title":"<code>preprocess(df: pd.DataFrame) -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n    df = df.copy(deep=True)\n    df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n    df = self.smoothen(df, window_size=self.smoothing_windows_size)\n    df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n    if self.drop_background_fluorescence_cols:\n        df = df.drop(columns=self.background_fluorescence_cols_names)\n    df = self.normalize(\n        df=df,\n        sampling_start_frame=self.normalization_sampling_start_frame,\n        sampling_end_frame=self.normalization_sampling_end_frame\n    )\n    df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.reject_noise","title":"<code>reject_noise(df: pd.DataFrame, *, start_index: int = 35, factor_mean: float = 7.0, factor_peak: float = 2.0, overshoot_thresh: float = 2.0, overshoot_repl: float = 3.0) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Drop columns considered artifactual.</p> <p>Criteria (mirrors original MATLAB logic):</p> <ol> <li>Global peak occurs before the rising point  \u2192 remove column.</li> <li>Pre-rise segment too noisy (see <code>noisy_pre_rise</code>)            \u2192 remove.</li> <li>Overshoot spikes above threshold are corrected in-place    before criteria 1\u20132 are evaluated.</li> </ol>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.reject_noise--returns","title":"Returns","text":"<p>pd.DataFrame     Cleaned dataframe with offending columns removed.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef reject_noise(\n        df: pd.DataFrame,\n        *,\n        start_index: int = 35,\n        factor_mean: float = 7.0,\n        factor_peak: float = 2.0,\n        overshoot_thresh: float = 2.0,\n        overshoot_repl: float = 3.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Drop columns considered artifactual.\n\n    Criteria (mirrors original MATLAB logic):\n\n    1. Global peak occurs before the rising point  \u2192 remove column.\n    2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n    3. Overshoot spikes above threshold are *corrected* in-place\n       before criteria 1\u20132 are evaluated.\n\n    Returns\n    -------\n    pd.DataFrame\n        Cleaned dataframe with offending columns removed.\n    \"\"\"\n    cleaned = df.copy(deep=True)\n\n    for col in cleaned.columns:\n        s = cleaned[col]\n\n        # step-wise overshoot correction (in-place)\n        cleaned[col] = Preprocessor.correct_overshoot(\n            s,\n            factor_threshold=overshoot_thresh,\n            factor_replacement=overshoot_repl,\n        )\n\n        if Preprocessor.noisy_pre_rise(\n                cleaned[col], factor_mean, factor_peak, start_index\n        ):\n            cleaned.drop(columns=[col], inplace=True)\n\n    return cleaned\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.smoothen","title":"<code>smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    return df.rolling(\n        window=window_size,\n        min_periods=1,  # allow smaller windows at edges\n        center=True\n    ).mean()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Preprocessor.subtract_baseline_fluorescence","title":"<code>subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n    averaged = df[background_roi_cols].mean(axis=1)\n    result_df = df.subtract(averaged, axis=0)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI","title":"<code>ROI</code>","text":"<p>A class representing a single region of interest (ROI) in calcium imaging data.</p> <p>This class handles the analysis and visualization of calcium imaging data for a single ROI, including calculation of influx/eflux rates, amplitude, integral, and tau values.</p> <p>Attributes:</p> Name Type Description <code>coverslip_id</code> <code>int</code> <p>The ID of the coverslip this ROI belongs to.</p> <code>roi_id</code> <code>int</code> <p>The unique identifier for this ROI.</p> <code>group_type</code> <code>str</code> <p>The type of group this ROI belongs to.</p> <code>name</code> <code>str</code> <p>A formatted name combining coverslip and ROI IDs.</p> <code>title</code> <code>str</code> <p>A descriptive title for the ROI.</p> <code>time</code> <code>Series</code> <p>Time series data for the ROI.</p> <code>trace</code> <code>Series</code> <p>Fluorescence trace data for the ROI.</p> <code>onset_idx</code> <code>int</code> <p>Index of the onset of the calcium response.</p> <code>peak_idx</code> <code>int</code> <p>Index of the peak of the calcium response.</p> <code>influx_start_idx</code> <code>int</code> <p>Start index for influx calculation.</p> <code>influx_end_idx</code> <code>int</code> <p>End index for influx calculation.</p> <code>eflux_start_idx</code> <code>int</code> <p>Start index for eflux calculation.</p> <code>eflux_end_idx</code> <code>int</code> <p>End index for eflux calculation.</p> <code>baseline_return_idx</code> <code>int</code> <p>Index where the trace returns to baseline.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>class ROI:\n    \"\"\"A class representing a single region of interest (ROI) in calcium imaging data.\n\n    This class handles the analysis and visualization of calcium imaging data for a single ROI,\n    including calculation of influx/eflux rates, amplitude, integral, and tau values.\n\n    Attributes:\n        coverslip_id (int): The ID of the coverslip this ROI belongs to.\n        roi_id (int): The unique identifier for this ROI.\n        group_type (str): The type of group this ROI belongs to.\n        name (str): A formatted name combining coverslip and ROI IDs.\n        title (str): A descriptive title for the ROI.\n        time (pd.Series): Time series data for the ROI.\n        trace (pd.Series): Fluorescence trace data for the ROI.\n        onset_idx (int): Index of the onset of the calcium response.\n        peak_idx (int): Index of the peak of the calcium response.\n        influx_start_idx (int): Start index for influx calculation.\n        influx_end_idx (int): End index for influx calculation.\n        eflux_start_idx (int): Start index for eflux calculation.\n        eflux_end_idx (int): End index for eflux calculation.\n        baseline_return_idx (int): Index where the trace returns to baseline.\n    \"\"\"\n    EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5\n\n    def __init__(\n            self,\n            trace: pd.Series,\n            time: pd.Series,\n            roi_id: int,\n            coverslip_id: int,\n            group_type: str,\n    ) -&gt; None:\n        \"\"\"Initialize a new ROI instance.\n\n        Args:\n            trace (pd.Series): The fluorescence trace data for this ROI.\n            time (pd.Series): The time series data corresponding to the trace.\n            roi_id (int): The unique identifier for this ROI.\n            coverslip_id (int): The ID of the coverslip this ROI belongs to.\n            group_type (str): The type of group this ROI belongs to.\n        \"\"\"\n        self.coverslip_id = coverslip_id\n        self.roi_id = roi_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.coverslip_id}_roi-{self.roi_id}\"\n        self.title = f\"ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})\"\n        self.time = time.copy(deep=True).rename(f\"time_{self.name}\")\n        self.trace = trace.copy(deep=True).rename(self.name)\n        self.onset_idx = detect_onset_index(self.trace)\n        self.peak_idx = detect_peak_index(self.trace)\n        self.influx_start_idx = self.onset_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.eflux_end_idx = detect_eflux_end_index(self.trace)\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def shift_trace(self, periods: int) -&gt; None:\n        \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n        Args:\n            periods (int): Number of periods to shift the trace and indices.\n        \"\"\"\n        self.time = self.time.shift(periods)\n        self.trace = self.trace.shift(periods)\n        self.onset_idx = self.onset_idx + periods\n        self.peak_idx = self.peak_idx + periods\n        self.influx_start_idx = self.influx_start_idx + periods\n        self.influx_end_idx = self.influx_end_idx + periods\n        self.eflux_start_idx = self.eflux_start_idx + periods\n        self.eflux_end_idx = self.eflux_end_idx + periods\n        self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n\n    def calculate_influx(self) -&gt; float:\n        \"\"\"Calculate the influx rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated influx rate.\n        \"\"\"\n        return calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        ).slope\n\n    def calculate_eflux(self) -&gt; float:\n        \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated eflux rate.\n        \"\"\"\n        return calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        ).slope\n\n    def calculate_amplitude(self) -&gt; float:\n        \"\"\"Calculate the amplitude of the calcium response.\n\n        Returns:\n            float: The amplitude, calculated as the peak value minus 1.\n        \"\"\"\n        return self.trace[self.peak_idx] - 1\n\n    def calculate_integral(self) -&gt; float:\n        \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n        Returns:\n            float: The calculated integral of the trace.\n\n        Raises:\n            ValueError: If baseline_return_idx is not set (equals -999).\n        \"\"\"\n        # Get the relevant portions of the trace and time series\n        trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n        time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n        # Calculate integral using trapezoidal rule\n        integral = np.trapz(trace_segment, time_segment)\n        return integral\n\n    def calculate_tau(self) -&gt; float:\n        \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n        Tau is calculated as the time between the peak and when the trace reaches\n        63.2% of the amplitude decay from peak.\n\n        Returns:\n            float: The calculated tau value.\n        \"\"\"\n        peak_value = self.trace[self.peak_idx]\n        target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n        # Search forward from peak to find where trace crosses target value\n        for idx in range(self.peak_idx, len(self.trace)):\n            if self.trace.loc[idx] &lt;= target_value:\n                return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n        return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n        Args:\n            title_prefix (Optional[str]): Optional prefix to add to the plot title.\n        \"\"\"\n        influx_linear_coefficients = calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        )\n        eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        )\n        create_traces_figure(\n            main_trace=self.trace,\n            title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            main_trace_peak_index=self.peak_idx,\n            main_trace_onset_index=self.onset_idx,\n            main_trace_baseline_return_index=self.baseline_return_idx,\n            eflux_linear_coefficients=eflux_linear_coefficients,\n            influx_linear_coefficients=influx_linear_coefficients\n        ).show()\n\n    def set_peak_idx(self, peak_idx: int) -&gt; None:\n        \"\"\"Set a new peak index and update related indices.\n\n        Args:\n            peak_idx (int): The new peak index to set.\n        \"\"\"\n        self.peak_idx = peak_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def set_onset_idx(self, onset_idx: int) -&gt; None:\n        \"\"\"Set a new onset index and update related indices.\n\n        Args:\n            onset_idx (int): The new onset index to set.\n        \"\"\"\n        self.onset_idx = onset_idx\n        self.influx_start_idx = self.onset_idx\n\n    def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n        \"\"\"Set a new baseline return index.\n\n        Args:\n            baseline_return_idx (int): The new baseline return index to set.\n        \"\"\"\n        self.baseline_return_idx = baseline_return_idx\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the ROI.\n\n        Returns:\n            str: A string containing the ROI's title.\n        \"\"\"\n        return self.title\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.EFLUX_START_INDEX_OFFSET_FROM_PEAK","title":"<code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.baseline_return_idx","title":"<code>baseline_return_idx = detect_baseline_return_idx(self.trace, self.eflux_start_idx)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.coverslip_id","title":"<code>coverslip_id = coverslip_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.eflux_end_idx","title":"<code>eflux_end_idx = detect_eflux_end_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.eflux_start_idx","title":"<code>eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.group_type","title":"<code>group_type = group_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.influx_end_idx","title":"<code>influx_end_idx = self.peak_idx</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.influx_start_idx","title":"<code>influx_start_idx = self.onset_idx</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.name","title":"<code>name = f'cs-{self.coverslip_id}_roi-{self.roi_id}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.onset_idx","title":"<code>onset_idx = detect_onset_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.peak_idx","title":"<code>peak_idx = detect_peak_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.roi_id","title":"<code>roi_id = roi_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.time","title":"<code>time = time.copy(deep=True).rename(f'time_{self.name}')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.title","title":"<code>title = f'ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.trace","title":"<code>trace = trace.copy(deep=True).rename(self.name)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.calculate_amplitude","title":"<code>calculate_amplitude() -&gt; float</code>","text":"<p>Calculate the amplitude of the calcium response.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The amplitude, calculated as the peak value minus 1.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_amplitude(self) -&gt; float:\n    \"\"\"Calculate the amplitude of the calcium response.\n\n    Returns:\n        float: The amplitude, calculated as the peak value minus 1.\n    \"\"\"\n    return self.trace[self.peak_idx] - 1\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.calculate_eflux","title":"<code>calculate_eflux() -&gt; float</code>","text":"<p>Calculate the eflux rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated eflux rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_eflux(self) -&gt; float:\n    \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated eflux rate.\n    \"\"\"\n    return calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    ).slope\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.calculate_influx","title":"<code>calculate_influx() -&gt; float</code>","text":"<p>Calculate the influx rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated influx rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_influx(self) -&gt; float:\n    \"\"\"Calculate the influx rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated influx rate.\n    \"\"\"\n    return calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    ).slope\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.calculate_integral","title":"<code>calculate_integral() -&gt; float</code>","text":"<p>Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated integral of the trace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If baseline_return_idx is not set (equals -999).</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_integral(self) -&gt; float:\n    \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n    Returns:\n        float: The calculated integral of the trace.\n\n    Raises:\n        ValueError: If baseline_return_idx is not set (equals -999).\n    \"\"\"\n    # Get the relevant portions of the trace and time series\n    trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n    time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n    # Calculate integral using trapezoidal rule\n    integral = np.trapz(trace_segment, time_segment)\n    return integral\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.calculate_tau","title":"<code>calculate_tau() -&gt; float</code>","text":"<p>Calculate the time constant (tau) of the calcium response decay.</p> <p>Tau is calculated as the time between the peak and when the trace reaches 63.2% of the amplitude decay from peak.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated tau value.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_tau(self) -&gt; float:\n    \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n    Tau is calculated as the time between the peak and when the trace reaches\n    63.2% of the amplitude decay from peak.\n\n    Returns:\n        float: The calculated tau value.\n    \"\"\"\n    peak_value = self.trace[self.peak_idx]\n    target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n    # Search forward from peak to find where trace crosses target value\n    for idx in range(self.peak_idx, len(self.trace)):\n        if self.trace.loc[idx] &lt;= target_value:\n            return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n    return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.set_baseline_return_idx","title":"<code>set_baseline_return_idx(baseline_return_idx: int) -&gt; None</code>","text":"<p>Set a new baseline return index.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_return_idx</code> <code>int</code> <p>The new baseline return index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n    \"\"\"Set a new baseline return index.\n\n    Args:\n        baseline_return_idx (int): The new baseline return index to set.\n    \"\"\"\n    self.baseline_return_idx = baseline_return_idx\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.set_onset_idx","title":"<code>set_onset_idx(onset_idx: int) -&gt; None</code>","text":"<p>Set a new onset index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>onset_idx</code> <code>int</code> <p>The new onset index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_onset_idx(self, onset_idx: int) -&gt; None:\n    \"\"\"Set a new onset index and update related indices.\n\n    Args:\n        onset_idx (int): The new onset index to set.\n    \"\"\"\n    self.onset_idx = onset_idx\n    self.influx_start_idx = self.onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.set_peak_idx","title":"<code>set_peak_idx(peak_idx: int) -&gt; None</code>","text":"<p>Set a new peak index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>peak_idx</code> <code>int</code> <p>The new peak index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_peak_idx(self, peak_idx: int) -&gt; None:\n    \"\"\"Set a new peak index and update related indices.\n\n    Args:\n        peak_idx (int): The new peak index to set.\n    \"\"\"\n    self.peak_idx = peak_idx\n    self.influx_end_idx = self.peak_idx\n    self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n    self.baseline_return_idx = detect_baseline_return_idx(\n        self.trace, self.eflux_start_idx\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.shift_trace","title":"<code>shift_trace(periods: int) -&gt; None</code>","text":"<p>Shift the trace and all associated indices by a specified number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to shift the trace and indices.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def shift_trace(self, periods: int) -&gt; None:\n    \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n    Args:\n        periods (int): Number of periods to shift the trace and indices.\n    \"\"\"\n    self.time = self.time.shift(periods)\n    self.trace = self.trace.shift(periods)\n    self.onset_idx = self.onset_idx + periods\n    self.peak_idx = self.peak_idx + periods\n    self.influx_start_idx = self.influx_start_idx + periods\n    self.influx_end_idx = self.influx_end_idx + periods\n    self.eflux_start_idx = self.eflux_start_idx + periods\n    self.eflux_end_idx = self.eflux_end_idx + periods\n    self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ROI.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"<p>Create and display a visualization of the ROI trace with key points marked.</p> <p>Parameters:</p> Name Type Description Default <code>title_prefix</code> <code>Optional[str]</code> <p>Optional prefix to add to the plot title.</p> <code>None</code> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n    Args:\n        title_prefix (Optional[str]): Optional prefix to add to the plot title.\n    \"\"\"\n    influx_linear_coefficients = calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    )\n    eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    )\n    create_traces_figure(\n        main_trace=self.trace,\n        title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        main_trace_peak_index=self.peak_idx,\n        main_trace_onset_index=self.onset_idx,\n        main_trace_baseline_return_index=self.baseline_return_idx,\n        eflux_linear_coefficients=eflux_linear_coefficients,\n        influx_linear_coefficients=influx_linear_coefficients\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Research","title":"<code>Research</code>","text":"<p>A collection of multiple experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>class Research:\n    \"\"\"A collection of multiple experiments.\"\"\"\n\n    def __init__(self, name: str, experiments: List[Experiment]) -&gt; None:\n        \"\"\"Holds multiple experiments of the same research project.\"\"\"\n        self.name = name\n        self.experiments = sorted(experiments, key=lambda e: e.name)\n        self._id2experiment = {e.name: e for e in self.experiments}\n        self.num_experiments = len(self.experiments)\n        self.num_groups = sum(e.num_groups for e in self.experiments)\n        self.num_rois = sum(e.num_rois for e in self.experiments)\n        self.title = f\"{name} (Experiments {', '.join([e.name for e in self.experiments])})\"\n\n    def __getitem__(self, experiment_name: str) -&gt; Experiment:\n        return self._id2experiment[experiment_name]\n\n    def __len__(self) -&gt; int:\n        return len(self.experiments)\n\n    def __iter__(self) -&gt; Iterator[Experiment]:\n        return iter(self.experiments)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n        dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n        df = pd.concat(dfs, axis=0)\n        df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n        \"\"\"Save analysis results for all experiments.\"\"\"\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Save individual experiment results\n        for experiment in self.experiments:\n            experiment.save_mega_dfs(results_output_dir_path)\n\n        # Save combined results\n        combined_df = self.get_full_analysis_df()\n        base = results_output_dir_path / \"combined_analysis\"\n        combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Research-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.experiments","title":"<code>experiments = sorted(experiments, key=lambda e: e.name)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.num_experiments","title":"<code>num_experiments = len(self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.num_groups","title":"<code>num_groups = sum(e.num_groups for e in self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.num_rois","title":"<code>num_rois = sum(e.num_rois for e in self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.title","title":"<code>title = f'{name} (Experiments {', '.join([e.name for e in self.experiments])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.Research.get_full_analysis_df","title":"<code>get_full_analysis_df() -&gt; pd.DataFrame</code>","text":"<p>Get a combined DataFrame of all experiments' analysis results.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n    dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n    df = pd.concat(dfs, axis=0)\n    df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.Research.save_mega_dfs","title":"<code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code>","text":"<p>Save analysis results for all experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n    \"\"\"Save analysis results for all experiments.\"\"\"\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n    # Save individual experiment results\n    for experiment in self.experiments:\n        experiment.save_mega_dfs(results_output_dir_path)\n\n    # Save combined results\n    combined_df = self.get_full_analysis_df()\n    base = results_output_dir_path / \"combined_analysis\"\n    combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n    combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.extract_coverslip_info_from_filename_stem","title":"<code>extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo</code>","text":"<p>Extracts coverslip ID and group type from a string of the form ' - ' and returns a CoverslipInfo tuple."},{"location":"reference/calcium_imaging/#calcium_imaging.extract_coverslip_info_from_filename_stem--parameters","title":"Parameters","text":"<p>filename : str     The filename or label to parse.</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.extract_coverslip_info_from_filename_stem--returns","title":"Returns","text":"<p>CoverslipInfo     NamedTuple(coverslip_id, group_type)</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.extract_coverslip_info_from_filename_stem--raises","title":"Raises","text":"<p>ValueError     If <code>name</code> doesn\u2019t match the expected pattern.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>def extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo:\n    \"\"\"\n    Extracts coverslip ID and group type from a string of the form\n    '&lt;coverslip_id&gt; - &lt;group_type&gt;' and returns a CoverslipInfo tuple.\n\n    Parameters\n    ----------\n    filename : str\n        The filename or label to parse.\n\n    Returns\n    -------\n    CoverslipInfo\n        NamedTuple(coverslip_id, group_type)\n\n    Raises\n    ------\n    ValueError\n        If `name` doesn\u2019t match the expected pattern.\n    \"\"\"\n    m = COVERSLIP_FILENAME_STEM_PATTERN.match(filename)\n    if not m:\n        raise ValueError(\n            f\"Invalid format {filename!r}; expected '&lt;coverslip_id&gt; - &lt;group_type&gt;'.\"\n        )\n    return CoverslipInfo(\n        coverslip_id=int(m.group('coverslip_id')),\n        group_type=m.group('group_type').strip()\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.analysis","title":"<code>analysis</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.analysis-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.analysis-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.analysis-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.baseline_return_detection","title":"<code>baseline_return_detection</code>","text":"Functions\u00b6 <code>detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int</code> \u00b6 <p>Detects the index where the trace crosses the eflux linear fit (returns to baseline). Args:     trace (pd.Series): The fluorescence trace.     eflux_start_idx (int): Start index for eflux. Returns:     int: Index where trace crosses the eflux linear fit.</p> Source code in <code>src\\calcium_imaging\\analysis\\baseline_return_detection.py</code> <pre><code>def detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int:\n    \"\"\"\n    Detects the index where the trace crosses the eflux linear fit (returns to baseline).\n    Args:\n        trace (pd.Series): The fluorescence trace.\n        eflux_start_idx (int): Start index for eflux.\n    Returns:\n        int: Index where trace crosses the eflux linear fit.\n    \"\"\"\n    for idx in range(eflux_start_idx, trace.index[-1], 1):\n        if trace.loc[idx] &lt;= 1:\n            return idx\n    return trace.index[-1]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.eflux_calculation","title":"<code>eflux_calculation</code>","text":"Attributes\u00b6 <code>EFLUX_END_INDEX_MAX_OFFSET_FROM_START = 30</code> <code>module-attribute</code> \u00b6 <code>EFLUX_END_INDEX_MIN_OFFSET_FROM_START = 3</code> <code>module-attribute</code> \u00b6 <code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code> <code>module-attribute</code> \u00b6 Classes\u00b6 Functions\u00b6 <code>calculate_eflux_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code> \u00b6 Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def calculate_eflux_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating eflux for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &gt;= 0:\n        print(f\"Warning: eflux is non-negative for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre> <code>detect_eflux_end_index(trace: pd.Series) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_end_index(trace: pd.Series) -&gt; int:\n    start_idx = detect_eflux_start_index(trace)\n    end_idx = min(\n        start_idx + EFLUX_END_INDEX_MAX_OFFSET_FROM_START,\n        trace.index.values.max()  # prevent out of bounds\n    )\n    while end_idx &gt; start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START:\n        if trace.loc[end_idx] &gt;= 1.0:  # above baseline fluorescence level\n            return end_idx\n        end_idx -= 1\n    return end_idx  # start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START\n</code></pre> <code>detect_eflux_start_index(trace: pd.Series) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_start_index(trace: pd.Series) -&gt; int:\n    return detect_peak_index(trace) + EFLUX_START_INDEX_OFFSET_FROM_PEAK\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.influx_calculation","title":"<code>influx_calculation</code>","text":"Attributes\u00b6 <code>INFLUX_END_INDEX_OFFSET_FROM_PEAK = 1</code> <code>module-attribute</code> \u00b6 <code>INFLUX_START_INDEX_MAX_OFFSET_FROM_END = 60</code> <code>module-attribute</code> \u00b6 <code>INFLUX_START_INDEX_MIN_OFFSET_FROM_END = 2</code> <code>module-attribute</code> \u00b6 Classes\u00b6 Functions\u00b6 <code>calculate_influx_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code> \u00b6 Source code in <code>src\\calcium_imaging\\analysis\\influx_calculation.py</code> <pre><code>def calculate_influx_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating influx for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &lt;= 0:\n        print(f\"Warning: influx is non-positive for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.linear_fit","title":"<code>linear_fit</code>","text":"Classes\u00b6 Functions\u00b6 <code>linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D</code> \u00b6 Source code in <code>src\\calcium_imaging\\analysis\\linear_fit.py</code> <pre><code>def linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D:\n    y = trace.loc[start_idx:end_idx]\n    x = y.index.to_numpy().astype(float)\n    regression_coefficients = RegressionCoefficients1D(*polyfit(x, y, deg=1))\n    return regression_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.onset_detection","title":"<code>onset_detection</code>","text":"Functions\u00b6 <code>detect_onset_index(trace: pd.Series, start_bound: int = 40, end_bound: int = 80, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code> \u00b6 <p>Detects the onset of a transient in a trace within a given window.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: index to start searching for the onset - end_bound: index to stop searching - baseline_window: number of points before start_bound to estimate baseline fluctuation - sliding_window: size of the moving average window (delta computed over this window) - threshold_factor: multiplier of baseline std to define onset</p> <p>Returns: - onset index (int) within bounds where signal \"explodes\"</p> Source code in <code>src\\calcium_imaging\\analysis\\onset_detection.py</code> <pre><code>def detect_onset_index(\n        trace: pd.Series,\n        start_bound: int = 40,\n        end_bound: int = 80,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects the onset of a transient in a trace within a given window.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: index to start searching for the onset\n    - end_bound: index to stop searching\n    - baseline_window: number of points before start_bound to estimate baseline fluctuation\n    - sliding_window: size of the moving average window (delta computed over this window)\n    - threshold_factor: multiplier of baseline std to define onset\n\n    Returns:\n    - onset index (int) within bounds where signal \"explodes\"\n    \"\"\"\n    if start_bound - baseline_window &lt; 0:\n        raise ValueError(\"Not enough data before start_bound to compute baseline\")\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_std = baseline.diff().dropna().abs().mean()\n\n    for i in range(start_bound, end_bound - sliding_window):\n        window = trace.iloc[i:i + sliding_window]\n        delta = window.diff().abs().mean()\n        if delta &gt; threshold_factor * baseline_std:\n            return trace.index[i]\n\n    print(f\"No onset detected within the specified bounds for trace: {trace.name}\")\n    return start_bound\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.peak_detection","title":"<code>peak_detection</code>","text":"Functions\u00b6 <code>detect_peak_index(trace: pd.Series, end_bound: int = 120, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code> \u00b6 <p>Detects a peak in a trace within the given bounds.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: start index for peak search - end_bound: end index for peak search - baseline_window: window size before start_bound to estimate noise level - sliding_window: how many points to consider when comparing local max - threshold_factor: peak must exceed baseline by this factor (std units)</p> <p>Returns: - Index of detected peak (int)</p> Source code in <code>src\\calcium_imaging\\analysis\\peak_detection.py</code> <pre><code>def detect_peak_index(\n        trace: pd.Series,\n        end_bound: int = 120,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects a peak in a trace within the given bounds.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: start index for peak search\n    - end_bound: end index for peak search\n    - baseline_window: window size before start_bound to estimate noise level\n    - sliding_window: how many points to consider when comparing local max\n    - threshold_factor: peak must exceed baseline by this factor (std units)\n\n    Returns:\n    - Index of detected peak (int)\n    \"\"\"\n    start_bound = detect_onset_index(trace)\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_mean = baseline.mean()\n    baseline_std = baseline.std()\n\n    for i in range(start_bound + sliding_window, end_bound - sliding_window):\n        current = trace.iloc[i]\n        neighbors = trace.iloc[i - sliding_window:i + sliding_window + 1]\n        if (current == neighbors.max() and\n                current &gt; baseline_mean + threshold_factor * baseline_std):\n            return trace.index[i]\n\n    # fallback\n    return trace.index.values[trace.argmax()]\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.analysis.regression_coefficients","title":"<code>regression_coefficients</code>","text":"Classes\u00b6 <code>RegressionCoefficients1D</code> \u00b6 <p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\analysis\\regression_coefficients.py</code> <pre><code>class RegressionCoefficients1D(NamedTuple):\n    intercept: float\n    slope: float\n</code></pre> Attributes\u00b6 <code>intercept: float</code> <code>instance-attribute</code> \u00b6 <code>slope: float</code> <code>instance-attribute</code> \u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.data_models","title":"<code>data_models</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.data_models-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.data_models-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.data_models.coverslip","title":"<code>coverslip</code>","text":"Classes\u00b6 <code>Coverslip</code> \u00b6 <p>One plate</p> Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>class Coverslip:\n    \"\"\"One plate\"\"\"\n\n    def __init__(self, coverslip_id: int, group_type: str, rois: List[ROI]) -&gt; None:\n        self.rois = self._init_rois(rois)\n        self._id2roi = {roi.roi_id: roi for roi in self.rois}\n        self.id = coverslip_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.id}\"\n        self.title = f\"Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})\"\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, roi_id: int) -&gt; ROI:\n        return self._id2roi[roi_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.rois)\n\n    def __iter__(self) -&gt; Iterator[ROI]:\n        return iter(self.rois)\n\n    def drop_roi(self, roi_id: int) -&gt; None:\n        try:\n            self._id2roi.pop(roi_id)\n            self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n            print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n        except KeyError:\n            print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([roi.trace for roi in self.rois], axis=1)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for roi in self.rois]\n        rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n        rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"Coverslip {self.id} ({self.group_type})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n        mean_trace.name = f\"Coverslip {self.id} mean\"\n        return mean_trace\n\n    def _calculate_metric(\n            self,\n            metric_calculation_func: Callable[['ROI'], float],\n            metric_name: str,\n    ) -&gt; Union[List[float], List[Dict[str, float]]]:\n        return [\n            {\n                \"group_type\": self.group_type,\n                \"coverslip\": roi.coverslip_id,\n                \"roi\": roi.roi_id,\n                metric_name: metric_calculation_func(roi)\n            }\n            for roi in self.rois\n        ]\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_eflux(),\n            metric_name=\"eflux\",\n        )\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_amplitude(),\n            metric_name=\"amplitude\",\n        )\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_integral(),\n            metric_name=\"integral\",\n        )\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_tau(),\n            metric_name=\"tau\",\n        )\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n            print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n        for roi in self.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_rois(rois: List[ROI]) -&gt; List[ROI]:\n        rois = sorted(rois, key=lambda roi: roi.roi_id)\n        if len(rois) == 0:\n            raise ValueError(f\"Initializing class Coverslip with empty ROIs list is illegal.\")\n        if not all([roi.coverslip_id == rois[0].coverslip_id for roi in rois]):\n            raise ValueError(f\"All ROIs must share the same coverslip ID.\")\n        return rois\n</code></pre> Attributes\u00b6 <code>group_type = group_type</code> <code>instance-attribute</code> \u00b6 <code>id = coverslip_id</code> <code>instance-attribute</code> \u00b6 <code>name = f'cs-{self.id}'</code> <code>instance-attribute</code> \u00b6 <code>rois = self._init_rois(rois)</code> <code>instance-attribute</code> \u00b6 <code>title = f'Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n        print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n    for roi in self.rois:\n        roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_amplitude(),\n        metric_name=\"amplitude\",\n    )\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_eflux(),\n        metric_name=\"eflux\",\n    )\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_integral(),\n        metric_name=\"integral\",\n    )\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_tau(),\n        metric_name=\"tau\",\n    )\n</code></pre> <code>drop_roi(roi_id: int) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def drop_roi(self, roi_id: int) -&gt; None:\n    try:\n        self._id2roi.pop(roi_id)\n        self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n        print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n    except KeyError:\n        print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n</code></pre> <code>get_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([roi.trace for roi in self.rois], axis=1)\n</code></pre> <code>get_mean_trace() -&gt; pd.Series</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n    mean_trace.name = f\"Coverslip {self.id} mean\"\n    return mean_trace\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for roi in self.rois]\n    rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n    rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"Coverslip {self.id} ({self.group_type})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre> Functions\u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.data_models.experiment","title":"<code>experiment</code>","text":"Classes\u00b6 <code>Experiment</code> \u00b6 <p>A folder containing multiple Conditions, e.g., 'SI_SH_check'.</p> Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>class Experiment:\n    \"\"\"A folder containing multiple Conditions, e.g., 'SI_SH_check'.\"\"\"\n\n    def __init__(self, name: str, groups: List[Group]) -&gt; None:\n        \"\"\"Holds multiple groups of the same experiment.\"\"\"\n        self.name = name\n        self.groups = sorted(groups, key=lambda g: g.group_type)\n        self._id2group = {g.group_type: g for g in self.groups}\n        self.num_groups = len(self.groups)\n        self.num_rois = len([roi for roi in self.iter_rois()])\n        self.title = f\"{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})\"\n\n    def __getitem__(self, group_type: str) -&gt; Group:\n        return self._id2group[group_type]\n\n    def __len__(self) -&gt; int:\n        return len(self.groups)\n\n    def __iter__(self) -&gt; Iterator[Group]:\n        return iter(self.groups)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def visualize(self) -&gt; None:\n        colors = get_n_colors_from_palette(self.num_groups)\n\n        all_traces = []\n        max_trace_val = 0\n        for color, group in zip(colors, self.groups):\n            rois_traces = [roi.trace for cs in group for roi in cs]\n            average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n            average_trace.name = f\"{group.group_type} mean\"\n            if average_trace.max() &gt; max_trace_val:\n                max_trace_val = average_trace.max()\n            group_fig = create_traces_figure(\n                main_trace=average_trace,\n                traces_color=color\n            )\n            all_traces.append(group_fig.data[0])\n\n        # Combine all traces into one figure\n        fig = go.Figure(data=all_traces)\n        fig.update_layout(\n            title=self.name,\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            xaxis=dict(showgrid=False),\n            yaxis=dict(showgrid=False),\n            template=\"plotly_white\",\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=1,\n                xanchor=\"left\",\n                x=1.05,\n                font=dict(size=10),\n                traceorder=\"normal\",\n            ),\n        )\n        fig.show()\n\n    def align_onsets(self) -&gt; None:\n        print(\"aligning onsets within each group\")\n        target_onsets = [group.align_onsets() for group in self.groups]\n        target_onset_idx = int(np.median(target_onsets))\n\n        print(f\"aligning onsets across groups to {target_onset_idx}\")\n        for group in self.groups:\n            group.align_onsets(target_onset_idx)\n\n    def get_mean_traces_df(self) -&gt; pd.DataFrame:\n        mean_traces = [group.get_mean_trace() for group in self.groups]\n        df = pd.concat(mean_traces, axis=1)\n        return df\n\n    def visualize_all_rois(self) -&gt; None:\n        for roi in self.iter_rois():\n            try:\n                roi.visualize()\n            except Exception as e:\n                print(e)\n                print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n\n    def run_manual_analysis(self) -&gt; None:\n        for i, roi in enumerate(self.iter_rois()):\n            try:\n                print(f\"ROI {i}/{self.num_rois}\")\n                self._ask_to_update_params(roi)\n            except Exception as e:\n                print(e)\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n                drop = get_bool_input(\"drop ROI? (y/n): \")\n                if drop:\n                    msg = f\"deleted {roi.title}\"\n                    del roi\n                    print(msg)\n                else:\n                    self._ask_to_update_params(roi)\n\n    @staticmethod\n    def _ask_to_update_params(roi: ROI):\n        while True:\n            roi.visualize()\n            peak_idx = get_int_input(f\"peak_idx={roi.peak_idx}, enter to accept or input to edit: \")\n            if peak_idx is not None:\n                roi.set_peak_idx(peak_idx)\n\n            onset_idx = get_int_input(f\"onset_idx={roi.onset_idx}, enter to accept or input to edit: \")\n            if onset_idx is not None:\n                roi.set_onset_idx(onset_idx)\n\n            if peak_idx is not None or onset_idx is not None:\n                roi.visualize()\n            else:\n                break\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for group in self.groups\n            for eflux_rate in group.calculate_eflux_rates()\n        ]\n\n    def _get_eflux_rates_df(self) -&gt; pd.DataFrame:\n        records = self.calculate_eflux_rates()\n        df = pd.DataFrame.from_records(records)\n        cols = df.columns.tolist()\n        df[\"experiment_name\"] = self.name\n        new_cols_order = [\"experiment_name\"] + cols\n        df = df[new_cols_order]\n        df = df.sort_values(by=[\"coverslip\", \"roi\"], ascending=True)\n        return df\n\n    def visualize_eflux_bar_chart(self) -&gt; None:\n        df = self._get_eflux_rates_df()\n        group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n        # Compute SEM and 95% CI (approx)\n        group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n        group_stats['ci95'] = 1.96 * group_stats['sem']\n\n        # Plot with 95% CI as error bars\n        fig = go.Figure([\n            go.Bar(\n                x=group_stats.index,\n                y=group_stats['mean'],\n                error_y=dict(type='data', array=group_stats['ci95']),\n                name='Mean \u00b1 95% CI'\n            )\n        ])\n        fig.update_layout(\n            title=\"Eflux mean with 95% Confidence Interval\",\n            xaxis_title=\"Group Type\",\n            yaxis_title=\"Eflux\",\n            template=\"plotly_white\"\n        )\n        fig.show()\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for group in self.groups\n            for amplitude in group.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for group in self.groups\n            for integral in group.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for group in self.groups\n            for tau in group.calculate_taus()\n        ]\n\n    def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n        return {g.group_type: g.get_df() for g in self.groups}\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n        for group_type, df in self.get_group_type_to_df().items():\n            base = results_output_dir_path / group_type\n            df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n            df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n\n    def iter_rois(self) -&gt; Iterator[ROI]:\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    yield roi\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        records = []\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    try:\n                        eflux = roi.calculate_eflux()\n                    except RuntimeError:\n                        eflux = np.nan\n\n                    try:\n                        influx = roi.calculate_influx()\n                    except RuntimeError:\n                        influx = np.nan\n\n                    try:\n                        amplitude = roi.calculate_amplitude()\n                    except RuntimeError:\n                        amplitude = np.nan\n\n                    try:\n                        integral = roi.calculate_integral()\n                    except RuntimeError:\n                        integral = np.nan\n\n                    try:\n                        tau = roi.calculate_tau()\n                    except RuntimeError:\n                        tau = np.nan\n\n                    records.append({\n                        \"experiment_name\": self.name,\n                        \"group_type\": group.group_type,\n                        \"coverslip\": coverslip.id,\n                        \"roi\": roi.roi_id,\n                        \"onset_frame\": roi.onset_idx,\n                        \"peak_frame\": roi.peak_idx,\n                        \"eflux\": eflux,\n                        \"influx\": influx,\n                        \"amplitude\": amplitude,\n                        \"integral\": integral,\n                        \"tau\": tau,\n                    })\n\n        df = pd.DataFrame.from_records(records)\n        df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n</code></pre> Attributes\u00b6 <code>groups = sorted(groups, key=lambda g: g.group_type)</code> <code>instance-attribute</code> \u00b6 <code>name = name</code> <code>instance-attribute</code> \u00b6 <code>num_groups = len(self.groups)</code> <code>instance-attribute</code> \u00b6 <code>num_rois = len([roi for roi in self.iter_rois()])</code> <code>instance-attribute</code> \u00b6 <code>title = f'{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def align_onsets(self) -&gt; None:\n    print(\"aligning onsets within each group\")\n    target_onsets = [group.align_onsets() for group in self.groups]\n    target_onset_idx = int(np.median(target_onsets))\n\n    print(f\"aligning onsets across groups to {target_onset_idx}\")\n    for group in self.groups:\n        group.align_onsets(target_onset_idx)\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for group in self.groups\n        for amplitude in group.calculate_amplitudes()\n    ]\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for group in self.groups\n        for eflux_rate in group.calculate_eflux_rates()\n    ]\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for group in self.groups\n        for integral in group.calculate_integrals()\n    ]\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for group in self.groups\n        for tau in group.calculate_taus()\n    ]\n</code></pre> <code>get_full_analysis_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    records = []\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                try:\n                    eflux = roi.calculate_eflux()\n                except RuntimeError:\n                    eflux = np.nan\n\n                try:\n                    influx = roi.calculate_influx()\n                except RuntimeError:\n                    influx = np.nan\n\n                try:\n                    amplitude = roi.calculate_amplitude()\n                except RuntimeError:\n                    amplitude = np.nan\n\n                try:\n                    integral = roi.calculate_integral()\n                except RuntimeError:\n                    integral = np.nan\n\n                try:\n                    tau = roi.calculate_tau()\n                except RuntimeError:\n                    tau = np.nan\n\n                records.append({\n                    \"experiment_name\": self.name,\n                    \"group_type\": group.group_type,\n                    \"coverslip\": coverslip.id,\n                    \"roi\": roi.roi_id,\n                    \"onset_frame\": roi.onset_idx,\n                    \"peak_frame\": roi.peak_idx,\n                    \"eflux\": eflux,\n                    \"influx\": influx,\n                    \"amplitude\": amplitude,\n                    \"integral\": integral,\n                    \"tau\": tau,\n                })\n\n    df = pd.DataFrame.from_records(records)\n    df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre> <code>get_group_type_to_df() -&gt; Dict[str, pd.DataFrame]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n    return {g.group_type: g.get_df() for g in self.groups}\n</code></pre> <code>get_mean_traces_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_mean_traces_df(self) -&gt; pd.DataFrame:\n    mean_traces = [group.get_mean_trace() for group in self.groups]\n    df = pd.concat(mean_traces, axis=1)\n    return df\n</code></pre> <code>iter_rois() -&gt; Iterator[ROI]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def iter_rois(self) -&gt; Iterator[ROI]:\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                yield roi\n</code></pre> <code>run_manual_analysis() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def run_manual_analysis(self) -&gt; None:\n    for i, roi in enumerate(self.iter_rois()):\n        try:\n            print(f\"ROI {i}/{self.num_rois}\")\n            self._ask_to_update_params(roi)\n        except Exception as e:\n            print(e)\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n            drop = get_bool_input(\"drop ROI? (y/n): \")\n            if drop:\n                msg = f\"deleted {roi.title}\"\n                del roi\n                print(msg)\n            else:\n                self._ask_to_update_params(roi)\n</code></pre> <code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n    for group_type, df in self.get_group_type_to_df().items():\n        base = results_output_dir_path / group_type\n        df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n</code></pre> <code>visualize() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize(self) -&gt; None:\n    colors = get_n_colors_from_palette(self.num_groups)\n\n    all_traces = []\n    max_trace_val = 0\n    for color, group in zip(colors, self.groups):\n        rois_traces = [roi.trace for cs in group for roi in cs]\n        average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n        average_trace.name = f\"{group.group_type} mean\"\n        if average_trace.max() &gt; max_trace_val:\n            max_trace_val = average_trace.max()\n        group_fig = create_traces_figure(\n            main_trace=average_trace,\n            traces_color=color\n        )\n        all_traces.append(group_fig.data[0])\n\n    # Combine all traces into one figure\n    fig = go.Figure(data=all_traces)\n    fig.update_layout(\n        title=self.name,\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        template=\"plotly_white\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n    fig.show()\n</code></pre> <code>visualize_all_rois() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_all_rois(self) -&gt; None:\n    for roi in self.iter_rois():\n        try:\n            roi.visualize()\n        except Exception as e:\n            print(e)\n            print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n</code></pre> <code>visualize_eflux_bar_chart() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_eflux_bar_chart(self) -&gt; None:\n    df = self._get_eflux_rates_df()\n    group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n    # Compute SEM and 95% CI (approx)\n    group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n    group_stats['ci95'] = 1.96 * group_stats['sem']\n\n    # Plot with 95% CI as error bars\n    fig = go.Figure([\n        go.Bar(\n            x=group_stats.index,\n            y=group_stats['mean'],\n            error_y=dict(type='data', array=group_stats['ci95']),\n            name='Mean \u00b1 95% CI'\n        )\n    ])\n    fig.update_layout(\n        title=\"Eflux mean with 95% Confidence Interval\",\n        xaxis_title=\"Group Type\",\n        yaxis_title=\"Eflux\",\n        template=\"plotly_white\"\n    )\n    fig.show()\n</code></pre> Functions\u00b6 Modules\u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.data_models.group","title":"<code>group</code>","text":"Classes\u00b6 <code>Group</code> \u00b6 <p>One group with certain intervention, e.g. 'shNCLX'.</p> Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>class Group:\n    \"\"\"One group with certain intervention, e.g. 'shNCLX'.\"\"\"\n\n    def __init__(self, coverslips: List[Coverslip]) -&gt; None:\n        \"\"\"Holds multiple runs of the same group\"\"\"\n        self.coverslips = self._init_coverslips(coverslips)\n        self._id2coverslip = {cs.id: cs for cs in self.coverslips}\n        self.group_type = self._infer_group_type()\n        self.title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, coverslip_id: int) -&gt; Coverslip:\n        return self._id2coverslip[coverslip_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.coverslips)\n\n    def __iter__(self) -&gt; Iterator[Coverslip]:\n        return iter(self.coverslips)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n        rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n        rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n        mean_trace.name = f\"{self.group_type} mean\"\n        return mean_trace\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for cs in self.coverslips\n            for eflux_rate in cs.calculate_eflux_rates()\n        ]\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for cs in self.coverslips\n            for amplitude in cs.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for cs in self.coverslips\n            for integral in cs.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for cs in self.coverslips\n            for tau in cs.calculate_taus()\n        ]\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n            target_onset_idx = int(np.median(onset_indexes))\n            print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n        for coverslip in self.coverslips:\n            for roi in coverslip.rois:\n                roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_coverslips(coverslips: List[Coverslip]) -&gt; List[Coverslip]:\n        coverslips = sorted(coverslips, key=lambda cs: cs.id)\n        if len(coverslips) == 0:\n            raise ValueError(f\"Initializing class Group with empty Coverslips list is illegal.\")\n        if not all([cs.group_type == coverslips[0].group_type for cs in coverslips]):\n            raise ValueError(f\"All Coverslips must share the same group type.\")\n        return coverslips\n\n    def _infer_group_type(self) -&gt; str:\n        return self.coverslips[0].group_type\n</code></pre> Attributes\u00b6 <code>coverslips = self._init_coverslips(coverslips)</code> <code>instance-attribute</code> \u00b6 <code>group_type = self._infer_group_type()</code> <code>instance-attribute</code> \u00b6 <code>title = f'{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        target_onset_idx = int(np.median(onset_indexes))\n        print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n    for coverslip in self.coverslips:\n        for roi in coverslip.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for cs in self.coverslips\n        for amplitude in cs.calculate_amplitudes()\n    ]\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for cs in self.coverslips\n        for eflux_rate in cs.calculate_eflux_rates()\n    ]\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for cs in self.coverslips\n        for integral in cs.calculate_integrals()\n    ]\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for cs in self.coverslips\n        for tau in cs.calculate_taus()\n    ]\n</code></pre> <code>get_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n</code></pre> <code>get_mean_trace() -&gt; pd.Series</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n    mean_trace.name = f\"{self.group_type} mean\"\n    return mean_trace\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n    rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n    rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre> Functions\u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.data_models.research","title":"<code>research</code>","text":"Classes\u00b6 <code>Research</code> \u00b6 <p>A collection of multiple experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>class Research:\n    \"\"\"A collection of multiple experiments.\"\"\"\n\n    def __init__(self, name: str, experiments: List[Experiment]) -&gt; None:\n        \"\"\"Holds multiple experiments of the same research project.\"\"\"\n        self.name = name\n        self.experiments = sorted(experiments, key=lambda e: e.name)\n        self._id2experiment = {e.name: e for e in self.experiments}\n        self.num_experiments = len(self.experiments)\n        self.num_groups = sum(e.num_groups for e in self.experiments)\n        self.num_rois = sum(e.num_rois for e in self.experiments)\n        self.title = f\"{name} (Experiments {', '.join([e.name for e in self.experiments])})\"\n\n    def __getitem__(self, experiment_name: str) -&gt; Experiment:\n        return self._id2experiment[experiment_name]\n\n    def __len__(self) -&gt; int:\n        return len(self.experiments)\n\n    def __iter__(self) -&gt; Iterator[Experiment]:\n        return iter(self.experiments)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n        dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n        df = pd.concat(dfs, axis=0)\n        df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n        \"\"\"Save analysis results for all experiments.\"\"\"\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Save individual experiment results\n        for experiment in self.experiments:\n            experiment.save_mega_dfs(results_output_dir_path)\n\n        # Save combined results\n        combined_df = self.get_full_analysis_df()\n        base = results_output_dir_path / \"combined_analysis\"\n        combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre> Attributes\u00b6 <code>experiments = sorted(experiments, key=lambda e: e.name)</code> <code>instance-attribute</code> \u00b6 <code>name = name</code> <code>instance-attribute</code> \u00b6 <code>num_experiments = len(self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>num_groups = sum(e.num_groups for e in self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>num_rois = sum(e.num_rois for e in self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>title = f'{name} (Experiments {', '.join([e.name for e in self.experiments])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>get_full_analysis_df() -&gt; pd.DataFrame</code> \u00b6 <p>Get a combined DataFrame of all experiments' analysis results.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n    dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n    df = pd.concat(dfs, axis=0)\n    df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre> <code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code> \u00b6 <p>Save analysis results for all experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n    \"\"\"Save analysis results for all experiments.\"\"\"\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n    # Save individual experiment results\n    for experiment in self.experiments:\n        experiment.save_mega_dfs(results_output_dir_path)\n\n    # Save combined results\n    combined_df = self.get_full_analysis_df()\n    base = results_output_dir_path / \"combined_analysis\"\n    combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n    combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.data_models.roi","title":"<code>roi</code>","text":"Classes\u00b6 <code>ROI</code> \u00b6 <p>A class representing a single region of interest (ROI) in calcium imaging data.</p> <p>This class handles the analysis and visualization of calcium imaging data for a single ROI, including calculation of influx/eflux rates, amplitude, integral, and tau values.</p> <p>Attributes:</p> Name Type Description <code>coverslip_id</code> <code>int</code> <p>The ID of the coverslip this ROI belongs to.</p> <code>roi_id</code> <code>int</code> <p>The unique identifier for this ROI.</p> <code>group_type</code> <code>str</code> <p>The type of group this ROI belongs to.</p> <code>name</code> <code>str</code> <p>A formatted name combining coverslip and ROI IDs.</p> <code>title</code> <code>str</code> <p>A descriptive title for the ROI.</p> <code>time</code> <code>Series</code> <p>Time series data for the ROI.</p> <code>trace</code> <code>Series</code> <p>Fluorescence trace data for the ROI.</p> <code>onset_idx</code> <code>int</code> <p>Index of the onset of the calcium response.</p> <code>peak_idx</code> <code>int</code> <p>Index of the peak of the calcium response.</p> <code>influx_start_idx</code> <code>int</code> <p>Start index for influx calculation.</p> <code>influx_end_idx</code> <code>int</code> <p>End index for influx calculation.</p> <code>eflux_start_idx</code> <code>int</code> <p>Start index for eflux calculation.</p> <code>eflux_end_idx</code> <code>int</code> <p>End index for eflux calculation.</p> <code>baseline_return_idx</code> <code>int</code> <p>Index where the trace returns to baseline.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>class ROI:\n    \"\"\"A class representing a single region of interest (ROI) in calcium imaging data.\n\n    This class handles the analysis and visualization of calcium imaging data for a single ROI,\n    including calculation of influx/eflux rates, amplitude, integral, and tau values.\n\n    Attributes:\n        coverslip_id (int): The ID of the coverslip this ROI belongs to.\n        roi_id (int): The unique identifier for this ROI.\n        group_type (str): The type of group this ROI belongs to.\n        name (str): A formatted name combining coverslip and ROI IDs.\n        title (str): A descriptive title for the ROI.\n        time (pd.Series): Time series data for the ROI.\n        trace (pd.Series): Fluorescence trace data for the ROI.\n        onset_idx (int): Index of the onset of the calcium response.\n        peak_idx (int): Index of the peak of the calcium response.\n        influx_start_idx (int): Start index for influx calculation.\n        influx_end_idx (int): End index for influx calculation.\n        eflux_start_idx (int): Start index for eflux calculation.\n        eflux_end_idx (int): End index for eflux calculation.\n        baseline_return_idx (int): Index where the trace returns to baseline.\n    \"\"\"\n    EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5\n\n    def __init__(\n            self,\n            trace: pd.Series,\n            time: pd.Series,\n            roi_id: int,\n            coverslip_id: int,\n            group_type: str,\n    ) -&gt; None:\n        \"\"\"Initialize a new ROI instance.\n\n        Args:\n            trace (pd.Series): The fluorescence trace data for this ROI.\n            time (pd.Series): The time series data corresponding to the trace.\n            roi_id (int): The unique identifier for this ROI.\n            coverslip_id (int): The ID of the coverslip this ROI belongs to.\n            group_type (str): The type of group this ROI belongs to.\n        \"\"\"\n        self.coverslip_id = coverslip_id\n        self.roi_id = roi_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.coverslip_id}_roi-{self.roi_id}\"\n        self.title = f\"ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})\"\n        self.time = time.copy(deep=True).rename(f\"time_{self.name}\")\n        self.trace = trace.copy(deep=True).rename(self.name)\n        self.onset_idx = detect_onset_index(self.trace)\n        self.peak_idx = detect_peak_index(self.trace)\n        self.influx_start_idx = self.onset_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.eflux_end_idx = detect_eflux_end_index(self.trace)\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def shift_trace(self, periods: int) -&gt; None:\n        \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n        Args:\n            periods (int): Number of periods to shift the trace and indices.\n        \"\"\"\n        self.time = self.time.shift(periods)\n        self.trace = self.trace.shift(periods)\n        self.onset_idx = self.onset_idx + periods\n        self.peak_idx = self.peak_idx + periods\n        self.influx_start_idx = self.influx_start_idx + periods\n        self.influx_end_idx = self.influx_end_idx + periods\n        self.eflux_start_idx = self.eflux_start_idx + periods\n        self.eflux_end_idx = self.eflux_end_idx + periods\n        self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n\n    def calculate_influx(self) -&gt; float:\n        \"\"\"Calculate the influx rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated influx rate.\n        \"\"\"\n        return calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        ).slope\n\n    def calculate_eflux(self) -&gt; float:\n        \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated eflux rate.\n        \"\"\"\n        return calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        ).slope\n\n    def calculate_amplitude(self) -&gt; float:\n        \"\"\"Calculate the amplitude of the calcium response.\n\n        Returns:\n            float: The amplitude, calculated as the peak value minus 1.\n        \"\"\"\n        return self.trace[self.peak_idx] - 1\n\n    def calculate_integral(self) -&gt; float:\n        \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n        Returns:\n            float: The calculated integral of the trace.\n\n        Raises:\n            ValueError: If baseline_return_idx is not set (equals -999).\n        \"\"\"\n        # Get the relevant portions of the trace and time series\n        trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n        time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n        # Calculate integral using trapezoidal rule\n        integral = np.trapz(trace_segment, time_segment)\n        return integral\n\n    def calculate_tau(self) -&gt; float:\n        \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n        Tau is calculated as the time between the peak and when the trace reaches\n        63.2% of the amplitude decay from peak.\n\n        Returns:\n            float: The calculated tau value.\n        \"\"\"\n        peak_value = self.trace[self.peak_idx]\n        target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n        # Search forward from peak to find where trace crosses target value\n        for idx in range(self.peak_idx, len(self.trace)):\n            if self.trace.loc[idx] &lt;= target_value:\n                return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n        return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n        Args:\n            title_prefix (Optional[str]): Optional prefix to add to the plot title.\n        \"\"\"\n        influx_linear_coefficients = calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        )\n        eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        )\n        create_traces_figure(\n            main_trace=self.trace,\n            title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            main_trace_peak_index=self.peak_idx,\n            main_trace_onset_index=self.onset_idx,\n            main_trace_baseline_return_index=self.baseline_return_idx,\n            eflux_linear_coefficients=eflux_linear_coefficients,\n            influx_linear_coefficients=influx_linear_coefficients\n        ).show()\n\n    def set_peak_idx(self, peak_idx: int) -&gt; None:\n        \"\"\"Set a new peak index and update related indices.\n\n        Args:\n            peak_idx (int): The new peak index to set.\n        \"\"\"\n        self.peak_idx = peak_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def set_onset_idx(self, onset_idx: int) -&gt; None:\n        \"\"\"Set a new onset index and update related indices.\n\n        Args:\n            onset_idx (int): The new onset index to set.\n        \"\"\"\n        self.onset_idx = onset_idx\n        self.influx_start_idx = self.onset_idx\n\n    def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n        \"\"\"Set a new baseline return index.\n\n        Args:\n            baseline_return_idx (int): The new baseline return index to set.\n        \"\"\"\n        self.baseline_return_idx = baseline_return_idx\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the ROI.\n\n        Returns:\n            str: A string containing the ROI's title.\n        \"\"\"\n        return self.title\n</code></pre> Attributes\u00b6 <code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code>baseline_return_idx = detect_baseline_return_idx(self.trace, self.eflux_start_idx)</code> <code>instance-attribute</code> \u00b6 <code>coverslip_id = coverslip_id</code> <code>instance-attribute</code> \u00b6 <code>eflux_end_idx = detect_eflux_end_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK</code> <code>instance-attribute</code> \u00b6 <code>group_type = group_type</code> <code>instance-attribute</code> \u00b6 <code>influx_end_idx = self.peak_idx</code> <code>instance-attribute</code> \u00b6 <code>influx_start_idx = self.onset_idx</code> <code>instance-attribute</code> \u00b6 <code>name = f'cs-{self.coverslip_id}_roi-{self.roi_id}'</code> <code>instance-attribute</code> \u00b6 <code>onset_idx = detect_onset_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>peak_idx = detect_peak_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>roi_id = roi_id</code> <code>instance-attribute</code> \u00b6 <code>time = time.copy(deep=True).rename(f'time_{self.name}')</code> <code>instance-attribute</code> \u00b6 <code>title = f'ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})'</code> <code>instance-attribute</code> \u00b6 <code>trace = trace.copy(deep=True).rename(self.name)</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>calculate_amplitude() -&gt; float</code> \u00b6 <p>Calculate the amplitude of the calcium response.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The amplitude, calculated as the peak value minus 1.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_amplitude(self) -&gt; float:\n    \"\"\"Calculate the amplitude of the calcium response.\n\n    Returns:\n        float: The amplitude, calculated as the peak value minus 1.\n    \"\"\"\n    return self.trace[self.peak_idx] - 1\n</code></pre> <code>calculate_eflux() -&gt; float</code> \u00b6 <p>Calculate the eflux rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated eflux rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_eflux(self) -&gt; float:\n    \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated eflux rate.\n    \"\"\"\n    return calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    ).slope\n</code></pre> <code>calculate_influx() -&gt; float</code> \u00b6 <p>Calculate the influx rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated influx rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_influx(self) -&gt; float:\n    \"\"\"Calculate the influx rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated influx rate.\n    \"\"\"\n    return calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    ).slope\n</code></pre> <code>calculate_integral() -&gt; float</code> \u00b6 <p>Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated integral of the trace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If baseline_return_idx is not set (equals -999).</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_integral(self) -&gt; float:\n    \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n    Returns:\n        float: The calculated integral of the trace.\n\n    Raises:\n        ValueError: If baseline_return_idx is not set (equals -999).\n    \"\"\"\n    # Get the relevant portions of the trace and time series\n    trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n    time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n    # Calculate integral using trapezoidal rule\n    integral = np.trapz(trace_segment, time_segment)\n    return integral\n</code></pre> <code>calculate_tau() -&gt; float</code> \u00b6 <p>Calculate the time constant (tau) of the calcium response decay.</p> <p>Tau is calculated as the time between the peak and when the trace reaches 63.2% of the amplitude decay from peak.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated tau value.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_tau(self) -&gt; float:\n    \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n    Tau is calculated as the time between the peak and when the trace reaches\n    63.2% of the amplitude decay from peak.\n\n    Returns:\n        float: The calculated tau value.\n    \"\"\"\n    peak_value = self.trace[self.peak_idx]\n    target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n    # Search forward from peak to find where trace crosses target value\n    for idx in range(self.peak_idx, len(self.trace)):\n        if self.trace.loc[idx] &lt;= target_value:\n            return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n    return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n</code></pre> <code>set_baseline_return_idx(baseline_return_idx: int) -&gt; None</code> \u00b6 <p>Set a new baseline return index.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_return_idx</code> <code>int</code> <p>The new baseline return index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n    \"\"\"Set a new baseline return index.\n\n    Args:\n        baseline_return_idx (int): The new baseline return index to set.\n    \"\"\"\n    self.baseline_return_idx = baseline_return_idx\n</code></pre> <code>set_onset_idx(onset_idx: int) -&gt; None</code> \u00b6 <p>Set a new onset index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>onset_idx</code> <code>int</code> <p>The new onset index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_onset_idx(self, onset_idx: int) -&gt; None:\n    \"\"\"Set a new onset index and update related indices.\n\n    Args:\n        onset_idx (int): The new onset index to set.\n    \"\"\"\n    self.onset_idx = onset_idx\n    self.influx_start_idx = self.onset_idx\n</code></pre> <code>set_peak_idx(peak_idx: int) -&gt; None</code> \u00b6 <p>Set a new peak index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>peak_idx</code> <code>int</code> <p>The new peak index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_peak_idx(self, peak_idx: int) -&gt; None:\n    \"\"\"Set a new peak index and update related indices.\n\n    Args:\n        peak_idx (int): The new peak index to set.\n    \"\"\"\n    self.peak_idx = peak_idx\n    self.influx_end_idx = self.peak_idx\n    self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n    self.baseline_return_idx = detect_baseline_return_idx(\n        self.trace, self.eflux_start_idx\n    )\n</code></pre> <code>shift_trace(periods: int) -&gt; None</code> \u00b6 <p>Shift the trace and all associated indices by a specified number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to shift the trace and indices.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def shift_trace(self, periods: int) -&gt; None:\n    \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n    Args:\n        periods (int): Number of periods to shift the trace and indices.\n    \"\"\"\n    self.time = self.time.shift(periods)\n    self.trace = self.trace.shift(periods)\n    self.onset_idx = self.onset_idx + periods\n    self.peak_idx = self.peak_idx + periods\n    self.influx_start_idx = self.influx_start_idx + periods\n    self.influx_end_idx = self.influx_end_idx + periods\n    self.eflux_start_idx = self.eflux_start_idx + periods\n    self.eflux_end_idx = self.eflux_end_idx + periods\n    self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 <p>Create and display a visualization of the ROI trace with key points marked.</p> <p>Parameters:</p> Name Type Description Default <code>title_prefix</code> <code>Optional[str]</code> <p>Optional prefix to add to the plot title.</p> <code>None</code> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n    Args:\n        title_prefix (Optional[str]): Optional prefix to add to the plot title.\n    \"\"\"\n    influx_linear_coefficients = calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    )\n    eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    )\n    create_traces_figure(\n        main_trace=self.trace,\n        title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        main_trace_peak_index=self.peak_idx,\n        main_trace_onset_index=self.onset_idx,\n        main_trace_baseline_return_index=self.baseline_return_idx,\n        eflux_linear_coefficients=eflux_linear_coefficients,\n        influx_linear_coefficients=influx_linear_coefficients\n    ).show()\n</code></pre> Functions\u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]</code>","text":"<p>Extract the ROI ID from a column name of the form 'ROI  (Average)'."},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name.extract_roi_id_from_col_name--parameters","title":"Parameters","text":"<p>col_name : str     The column name to inspect.</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.extract_roi_id_from_col_name.extract_roi_id_from_col_name--returns","title":"Returns","text":"<p>Optional[int]     The integer ROI number if the name matches, otherwise None.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_roi_id_from_col_name.py</code> <pre><code>def extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]:\n    \"\"\"\n    Extract the ROI ID from a column name of the form 'ROI &lt;number&gt; (Average)'.\n\n    Parameters\n    ----------\n    col_name : str\n        The column name to inspect.\n\n    Returns\n    -------\n    Optional[int]\n        The integer ROI number if the name matches, otherwise None.\n    \"\"\"\n    m = ROI_COL_PATTERN.match(col_name)\n    return int(m.group(1)) if m else None\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.instantiation","title":"<code>instantiation</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.instantiation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.instantiation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.instantiation.load_experiment","title":"<code>load_experiment(experiment_dir: Union[str, Path], preprocessor: Preprocessor) -&gt; Experiment</code>","text":"<p>Reads an experiment directory and parses it into an Experiment class object</p> Source code in <code>src\\calcium_imaging\\instantiation.py</code> <pre><code>def load_experiment(experiment_dir: Union[str, Path], preprocessor: Preprocessor) -&gt; Experiment:\n    \"\"\"Reads an experiment directory and parses it into an Experiment class object\"\"\"\n    experiment_dir_path = validate_experiment_dir(experiment_dir)\n    coverslips = _instantiate_coverslips(experiment_dir_path, preprocessor)\n    groups = _instantiate_groups(coverslips)\n    experiment = _instantiate_experiment(\n        experiment_name=experiment_dir_path.stem,\n        groups=groups\n    )\n    return experiment\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.instantiation-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.io","title":"<code>io</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.io-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.io.load_vsi","title":"<code>load_vsi</code>","text":"Functions\u00b6 <code>load_vsi(path: Path) -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\io\\load_vsi.py</code> <pre><code>def load_vsi(path: Path) -&gt; pd.DataFrame:\n    if path.suffix == \".xls\":\n        return _load_xls(path)\n    raise ValueError(f\"Unsupported file type '{path.suffix}' for file '{path.resolve()}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.io.validate_experiment_dir","title":"<code>validate_experiment_dir</code>","text":"Functions\u00b6 <code>validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path</code> \u00b6 Source code in <code>src\\calcium_imaging\\io\\validate_experiment_dir.py</code> <pre><code>def validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path:\n    if isinstance(experiment_dir, str):\n        experiment_dir_path = Path(experiment_dir)\n    elif isinstance(experiment_dir, Path):\n        experiment_dir_path = experiment_dir\n    else:\n        raise ValueError(f\"Illegal type {type(experiment_dir)} for experiment_dir. \"\n                         f\"Provide either str or Path.\")\n    if not experiment_dir_path.exists():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' doesn't exist.\")\n    if not experiment_dir_path.is_dir():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' is not a directory.\")\n    return experiment_dir_path\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.load_vsi","title":"<code>load_vsi</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.load_vsi-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.load_vsi.load_vsi","title":"<code>load_vsi(path: Path) -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\io\\load_vsi.py</code> <pre><code>def load_vsi(path: Path) -&gt; pd.DataFrame:\n    if path.suffix == \".xls\":\n        return _load_xls(path)\n    raise ValueError(f\"Unsupported file type '{path.suffix}' for file '{path.resolve()}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing","title":"<code>processing</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.processing-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.processing-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.processing-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.processing.constants","title":"<code>constants</code>","text":"Attributes\u00b6 <code>BACKGROUND_FLUORESCENCE_ROIS = [BACKGROUND_FLUORESCENCE_ROI_1, BACKGROUND_FLUORESCENCE_ROI_2, BACKGROUND_FLUORESCENCE_ROI_3]</code> <code>module-attribute</code> \u00b6 <code>BACKGROUND_FLUORESCENCE_ROI_1 = 'ROI 1 (Average)'</code> <code>module-attribute</code> \u00b6 <code>BACKGROUND_FLUORESCENCE_ROI_2 = 'ROI 2 (Average)'</code> <code>module-attribute</code> \u00b6 <code>BACKGROUND_FLUORESCENCE_ROI_3 = 'ROI 3 (Average)'</code> <code>module-attribute</code> \u00b6 <code>COVERSLIP_FILENAME_STEM_PATTERN = re.compile('^\\\\s*(?P&lt;coverslip_id&gt;\\\\d+)\\\\s*-\\\\s*(?P&lt;group_type&gt;.+?)\\\\s*$')</code> <code>module-attribute</code> \u00b6 <code>ROI_COL_PATTERN = re.compile('^ROI\\\\s*(\\\\d+)\\\\s*\\\\(Average\\\\)$')</code> <code>module-attribute</code> \u00b6 <code>TIME_COL = 'Time (ms)'</code> <code>module-attribute</code> \u00b6"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_coverslip_info_from_filename","title":"<code>extract_coverslip_info_from_filename</code>","text":"Attributes\u00b6 Classes\u00b6 <code>CoverslipInfo</code> \u00b6 <p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>class CoverslipInfo(NamedTuple):\n    coverslip_id: int\n    group_type: str\n</code></pre> Attributes\u00b6 <code>coverslip_id: int</code> <code>instance-attribute</code> \u00b6 <code>group_type: str</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo</code> \u00b6 <p>Extracts coverslip ID and group type from a string of the form ' - ' and returns a CoverslipInfo tuple."},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--parameters","title":"Parameters","text":"<p>filename : str     The filename or label to parse.</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--returns","title":"Returns","text":"<p>CoverslipInfo     NamedTuple(coverslip_id, group_type)</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--raises","title":"Raises","text":"<p>ValueError     If <code>name</code> doesn\u2019t match the expected pattern.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>def extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo:\n    \"\"\"\n    Extracts coverslip ID and group type from a string of the form\n    '&lt;coverslip_id&gt; - &lt;group_type&gt;' and returns a CoverslipInfo tuple.\n\n    Parameters\n    ----------\n    filename : str\n        The filename or label to parse.\n\n    Returns\n    -------\n    CoverslipInfo\n        NamedTuple(coverslip_id, group_type)\n\n    Raises\n    ------\n    ValueError\n        If `name` doesn\u2019t match the expected pattern.\n    \"\"\"\n    m = COVERSLIP_FILENAME_STEM_PATTERN.match(filename)\n    if not m:\n        raise ValueError(\n            f\"Invalid format {filename!r}; expected '&lt;coverslip_id&gt; - &lt;group_type&gt;'.\"\n        )\n    return CoverslipInfo(\n        coverslip_id=int(m.group('coverslip_id')),\n        group_type=m.group('group_type').strip()\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name</code>","text":"Attributes\u00b6 Functions\u00b6 <code>extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]</code> \u00b6 <p>Extract the ROI ID from a column name of the form 'ROI  (Average)'."},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--parameters","title":"Parameters","text":"<p>col_name : str     The column name to inspect.</p>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--returns","title":"Returns","text":"<p>Optional[int]     The integer ROI number if the name matches, otherwise None.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_roi_id_from_col_name.py</code> <pre><code>def extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]:\n    \"\"\"\n    Extract the ROI ID from a column name of the form 'ROI &lt;number&gt; (Average)'.\n\n    Parameters\n    ----------\n    col_name : str\n        The column name to inspect.\n\n    Returns\n    -------\n    Optional[int]\n        The integer ROI number if the name matches, otherwise None.\n    \"\"\"\n    m = ROI_COL_PATTERN.match(col_name)\n    return int(m.group(1)) if m else None\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.preprocessor","title":"<code>preprocessor</code>","text":"Attributes\u00b6 Classes\u00b6 <code>Preprocessor</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>class Preprocessor:\n    def __init__(\n            self,\n            first_n_points_to_discard: int = 5,\n            smoothing_windows_size: int = 2,\n            time_col_name: str = TIME_COL,\n            background_fluorescence_cols_names: List[str] = BACKGROUND_FLUORESCENCE_ROIS,\n            normalization_sampling_start_frame: int = 1,\n            normalization_sampling_end_frame: int = 35,\n            earliest_onset_frame: int = 50,\n            earliest_baseline_recovery_frame: int = 90,\n            drop_traces_with_corrupted_peak: bool = False,\n            drop_background_fluorescence_cols: bool = True\n    ) -&gt; None:\n        self.first_n_points_to_discard = first_n_points_to_discard\n        self.smoothing_windows_size = smoothing_windows_size\n        self.time_col_name = time_col_name\n        self.background_fluorescence_cols_names = background_fluorescence_cols_names\n        self.normalization_sampling_start_frame = normalization_sampling_start_frame\n        self.normalization_sampling_end_frame = normalization_sampling_end_frame\n        self.earliest_onset_frame = earliest_onset_frame\n        self.earliest_baseline_recovery_frame = earliest_baseline_recovery_frame\n        self.drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak\n        self.drop_background_fluorescence_cols = drop_background_fluorescence_cols\n\n    def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        df = df.copy(deep=True)\n        df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n        df = self.smoothen(df, window_size=self.smoothing_windows_size)\n        df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n        if self.drop_background_fluorescence_cols:\n            df = df.drop(columns=self.background_fluorescence_cols_names)\n        df = self.normalize(\n            df=df,\n            sampling_start_frame=self.normalization_sampling_start_frame,\n            sampling_end_frame=self.normalization_sampling_end_frame\n        )\n        df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n        return df\n\n    @staticmethod\n    def discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n        return df.iloc[n:]\n\n    @staticmethod\n    def smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        return df.rolling(\n            window=window_size,\n            min_periods=1,  # allow smaller windows at edges\n            center=True\n        ).mean()\n\n    @staticmethod\n    def subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n        averaged = df[background_roi_cols].mean(axis=1)\n        result_df = df.subtract(averaged, axis=0)\n        return result_df\n\n    @staticmethod\n    def normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n        result_df = df.div(f0, axis=1)\n        return result_df\n\n    @staticmethod\n    def reject_noise(\n            df: pd.DataFrame,\n            *,\n            start_index: int = 35,\n            factor_mean: float = 7.0,\n            factor_peak: float = 2.0,\n            overshoot_thresh: float = 2.0,\n            overshoot_repl: float = 3.0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Drop columns considered artifactual.\n\n        Criteria (mirrors original MATLAB logic):\n\n        1. Global peak occurs before the rising point  \u2192 remove column.\n        2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n        3. Overshoot spikes above threshold are *corrected* in-place\n           before criteria 1\u20132 are evaluated.\n\n        Returns\n        -------\n        pd.DataFrame\n            Cleaned dataframe with offending columns removed.\n        \"\"\"\n        cleaned = df.copy(deep=True)\n\n        for col in cleaned.columns:\n            s = cleaned[col]\n\n            # step-wise overshoot correction (in-place)\n            cleaned[col] = Preprocessor.correct_overshoot(\n                s,\n                factor_threshold=overshoot_thresh,\n                factor_replacement=overshoot_repl,\n            )\n\n            if Preprocessor.noisy_pre_rise(\n                    cleaned[col], factor_mean, factor_peak, start_index\n            ):\n                cleaned.drop(columns=[col], inplace=True)\n\n        return cleaned\n\n    # ------------------------------------------------------------------\n    def _detect_traces_with_corrupted_peak(self, df: pd.DataFrame, drop: bool = False) -&gt; pd.DataFrame:\n        \"\"\"True if the global maximum is located *before* `start_index`.\"\"\"\n        result_df = df.copy(deep=True)\n        for col, trace in df.items():\n            idx_max = trace.index.values[trace.argmax()]\n            if idx_max &lt; self.earliest_onset_frame:\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n                print(f\"   warning {col}: peak detected before frame {self.earliest_onset_frame}, drop={drop}\")\n            if idx_max &gt; self.earliest_baseline_recovery_frame:\n                print(f\"   warning {col}: peak detected after frame {self.earliest_baseline_recovery_frame}, drop={drop}\")\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n        return result_df\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def correct_overshoot(\n            trace: pd.Series,\n            factor_threshold: float,\n            factor_replacement: float,\n            pre_window: int = 35,\n    ) -&gt; pd.Series:\n        \"\"\"\n        Clamp samples whose value exceeds\n            smooth + factor_threshold * mean_pre_peaks\n        to\n            smooth + factor_replacement * mean_pre_peaks.\n\n        The moving-average of the trace (window=10) is used as the\n        \u201csmooth\u201d estimate.\n        \"\"\"\n        if trace.isna().all():\n            return trace\n\n        smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n        # peaks only in the pre-rise region\n        peaks, _ = find_peaks(trace.iloc[:pre_window])\n        mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n        threshold = smooth + factor_threshold * mean_pre_peaks\n        replacement = smooth + factor_replacement * mean_pre_peaks\n\n        corrected = trace.where(trace &lt;= threshold, replacement)\n        return corrected\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def noisy_pre_rise(\n            trace: pd.Series,\n            factor_mean: float,\n            factor_peak: float,\n            start_index: int = 35,\n    ) -&gt; bool:\n        \"\"\"\n        Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n        Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n        Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n        \"\"\"\n        if trace.isna().all():\n            return True\n\n        pre_segment = trace.iloc[:start_index]\n        peaks, _ = find_peaks(pre_segment)\n\n        if peaks.size == 0:\n            return False  # no peaks \u21d2 not noisy by this definition\n\n        peaks_vals = pre_segment.iloc[peaks]\n        global_max = trace.max()\n\n        condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n        condition2 = peaks_vals.max() * factor_peak &gt; global_max\n        return condition1 or condition2\n</code></pre> Attributes\u00b6 <code>background_fluorescence_cols_names = background_fluorescence_cols_names</code> <code>instance-attribute</code> \u00b6 <code>drop_background_fluorescence_cols = drop_background_fluorescence_cols</code> <code>instance-attribute</code> \u00b6 <code>drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak</code> <code>instance-attribute</code> \u00b6 <code>earliest_baseline_recovery_frame = earliest_baseline_recovery_frame</code> <code>instance-attribute</code> \u00b6 <code>earliest_onset_frame = earliest_onset_frame</code> <code>instance-attribute</code> \u00b6 <code>first_n_points_to_discard = first_n_points_to_discard</code> <code>instance-attribute</code> \u00b6 <code>normalization_sampling_end_frame = normalization_sampling_end_frame</code> <code>instance-attribute</code> \u00b6 <code>normalization_sampling_start_frame = normalization_sampling_start_frame</code> <code>instance-attribute</code> \u00b6 <code>smoothing_windows_size = smoothing_windows_size</code> <code>instance-attribute</code> \u00b6 <code>time_col_name = time_col_name</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>correct_overshoot(trace: pd.Series, factor_threshold: float, factor_replacement: float, pre_window: int = 35) -&gt; pd.Series</code> <code>staticmethod</code> \u00b6 <p>Clamp samples whose value exceeds     smooth + factor_threshold * mean_pre_peaks to     smooth + factor_replacement * mean_pre_peaks.</p> <p>The moving-average of the trace (window=10) is used as the \u201csmooth\u201d estimate.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef correct_overshoot(\n        trace: pd.Series,\n        factor_threshold: float,\n        factor_replacement: float,\n        pre_window: int = 35,\n) -&gt; pd.Series:\n    \"\"\"\n    Clamp samples whose value exceeds\n        smooth + factor_threshold * mean_pre_peaks\n    to\n        smooth + factor_replacement * mean_pre_peaks.\n\n    The moving-average of the trace (window=10) is used as the\n    \u201csmooth\u201d estimate.\n    \"\"\"\n    if trace.isna().all():\n        return trace\n\n    smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n    # peaks only in the pre-rise region\n    peaks, _ = find_peaks(trace.iloc[:pre_window])\n    mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n    threshold = smooth + factor_threshold * mean_pre_peaks\n    replacement = smooth + factor_replacement * mean_pre_peaks\n\n    corrected = trace.where(trace &lt;= threshold, replacement)\n    return corrected\n</code></pre> <code>discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n    return df.iloc[n:]\n</code></pre> <code>noisy_pre_rise(trace: pd.Series, factor_mean: float, factor_peak: float, start_index: int = 35) -&gt; bool</code> <code>staticmethod</code> \u00b6 <p>Returns True if the pre-rise segment is noisy per MATLAB rules.</p> <p>Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef noisy_pre_rise(\n        trace: pd.Series,\n        factor_mean: float,\n        factor_peak: float,\n        start_index: int = 35,\n) -&gt; bool:\n    \"\"\"\n    Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n    Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n    Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n    \"\"\"\n    if trace.isna().all():\n        return True\n\n    pre_segment = trace.iloc[:start_index]\n    peaks, _ = find_peaks(pre_segment)\n\n    if peaks.size == 0:\n        return False  # no peaks \u21d2 not noisy by this definition\n\n    peaks_vals = pre_segment.iloc[peaks]\n    global_max = trace.max()\n\n    condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n    condition2 = peaks_vals.max() * factor_peak &gt; global_max\n    return condition1 or condition2\n</code></pre> <code>normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n    result_df = df.div(f0, axis=1)\n    return result_df\n</code></pre> <code>preprocess(df: pd.DataFrame) -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n    df = df.copy(deep=True)\n    df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n    df = self.smoothen(df, window_size=self.smoothing_windows_size)\n    df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n    if self.drop_background_fluorescence_cols:\n        df = df.drop(columns=self.background_fluorescence_cols_names)\n    df = self.normalize(\n        df=df,\n        sampling_start_frame=self.normalization_sampling_start_frame,\n        sampling_end_frame=self.normalization_sampling_end_frame\n    )\n    df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n    return df\n</code></pre> <code>reject_noise(df: pd.DataFrame, *, start_index: int = 35, factor_mean: float = 7.0, factor_peak: float = 2.0, overshoot_thresh: float = 2.0, overshoot_repl: float = 3.0) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Drop columns considered artifactual.</p> <p>Criteria (mirrors original MATLAB logic):</p> <ol> <li>Global peak occurs before the rising point  \u2192 remove column.</li> <li>Pre-rise segment too noisy (see <code>noisy_pre_rise</code>)            \u2192 remove.</li> <li>Overshoot spikes above threshold are corrected in-place    before criteria 1\u20132 are evaluated.</li> </ol> <code>smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    return df.rolling(\n        window=window_size,\n        min_periods=1,  # allow smaller windows at edges\n        center=True\n    ).mean()\n</code></pre> <code>subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n    averaged = df[background_roi_cols].mean(axis=1)\n    result_df = df.subtract(averaged, axis=0)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.processing.preprocessor.Preprocessor.reject_noise--returns","title":"Returns","text":"<p>pd.DataFrame     Cleaned dataframe with offending columns removed.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef reject_noise(\n        df: pd.DataFrame,\n        *,\n        start_index: int = 35,\n        factor_mean: float = 7.0,\n        factor_peak: float = 2.0,\n        overshoot_thresh: float = 2.0,\n        overshoot_repl: float = 3.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Drop columns considered artifactual.\n\n    Criteria (mirrors original MATLAB logic):\n\n    1. Global peak occurs before the rising point  \u2192 remove column.\n    2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n    3. Overshoot spikes above threshold are *corrected* in-place\n       before criteria 1\u20132 are evaluated.\n\n    Returns\n    -------\n    pd.DataFrame\n        Cleaned dataframe with offending columns removed.\n    \"\"\"\n    cleaned = df.copy(deep=True)\n\n    for col in cleaned.columns:\n        s = cleaned[col]\n\n        # step-wise overshoot correction (in-place)\n        cleaned[col] = Preprocessor.correct_overshoot(\n            s,\n            factor_threshold=overshoot_thresh,\n            factor_replacement=overshoot_repl,\n        )\n\n        if Preprocessor.noisy_pre_rise(\n                cleaned[col], factor_mean, factor_peak, start_index\n        ):\n            cleaned.drop(columns=[col], inplace=True)\n\n    return cleaned\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ui","title":"<code>ui</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ui-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.ui.get_bool_input","title":"<code>get_bool_input</code>","text":"Functions\u00b6 <code>get_bool_input(prompt: str) -&gt; bool</code> \u00b6 Source code in <code>src\\calcium_imaging\\ui\\get_bool_input.py</code> <pre><code>def get_bool_input(prompt: str) -&gt; bool:\n    true_values = {'y', 'yes', 'true', '1'}\n    false_values = {'n', 'no', 'false', '0'}\n\n    while True:\n        response = input(prompt).strip().lower()\n        if response in true_values:\n            return True\n        elif response in false_values:\n            return False\n        else:\n            print(\"Invalid input. Please enter a value like: y, yes, true, 1, n, no, false, or 0.\")\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.ui.get_int_input","title":"<code>get_int_input</code>","text":"Functions\u00b6 <code>get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None</code> \u00b6 Source code in <code>src\\calcium_imaging\\ui\\get_int_input.py</code> <pre><code>def get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None:\n    while True:\n        response = input(prompt).strip().lower()\n\n        if allow_none and (response == \"\" or response in {'none', 'skip'}):\n            return None\n\n        if response.isdigit() or (response.startswith('-') and response[1:].isdigit()):\n            value = int(response)\n            if (min_value is not None and value &lt; min_value) or \\\n               (max_value is not None and value &gt; max_value):\n                print(f\"Please enter an integer between {min_value} and {max_value}, or press Enter to skip.\")\n            else:\n                return value\n        else:\n            print(\"Invalid input. Please enter an integer\" + (\", or press Enter to skip.\" if allow_none else \".\"))\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.validate_experiment_dir","title":"<code>validate_experiment_dir</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.validate_experiment_dir-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.validate_experiment_dir.validate_experiment_dir","title":"<code>validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path</code>","text":"Source code in <code>src\\calcium_imaging\\io\\validate_experiment_dir.py</code> <pre><code>def validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path:\n    if isinstance(experiment_dir, str):\n        experiment_dir_path = Path(experiment_dir)\n    elif isinstance(experiment_dir, Path):\n        experiment_dir_path = experiment_dir\n    else:\n        raise ValueError(f\"Illegal type {type(experiment_dir)} for experiment_dir. \"\n                         f\"Provide either str or Path.\")\n    if not experiment_dir_path.exists():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' doesn't exist.\")\n    if not experiment_dir_path.is_dir():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' is not a directory.\")\n    return experiment_dir_path\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.viz","title":"<code>viz</code>","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.viz-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.viz-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/#calcium_imaging.viz.create_trace_figure","title":"<code>create_trace_figure</code>","text":"Classes\u00b6 Functions\u00b6 <code>create_traces_figure(main_trace: pd.Series, main_trace_peak_index: Optional[int] = None, main_trace_onset_index: Optional[int] = None, main_trace_baseline_return_index: Optional[int] = None, additional_traces: Optional[Iterable[pd.Series]] = None, additional_traces_peak_indexes: Optional[List[int]] = None, additional_traces_onset_indexes: Optional[List[int]] = None, additional_traces_baseline_return_indexes: Optional[List[int]] = None, title: Optional[str] = None, xaxis_title: Optional[str] = None, yaxis_title: Optional[str] = None, eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None, influx_linear_coefficients: Optional[RegressionCoefficients1D] = None, yaxis_range: Optional[Tuple[float, float]] = (0.5, 2), traces_color: Optional[str] = 'blue') -&gt; go.Figure</code> \u00b6 Source code in <code>src\\calcium_imaging\\viz\\create_trace_figure.py</code> <pre><code>def create_traces_figure(\n        main_trace: pd.Series,\n        main_trace_peak_index: Optional[int] = None,\n        main_trace_onset_index: Optional[int] = None,\n        main_trace_baseline_return_index: Optional[int] = None,\n        additional_traces: Optional[Iterable[pd.Series]] = None,\n        additional_traces_peak_indexes: Optional[List[int]] = None,\n        additional_traces_onset_indexes: Optional[List[int]] = None,\n        additional_traces_baseline_return_indexes: Optional[List[int]] = None,\n        title: Optional[str] = None,\n        xaxis_title: Optional[str] = None,\n        yaxis_title: Optional[str] = None,\n        eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        influx_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        yaxis_range: Optional[Tuple[float, float]] = (0.5, 2),\n        traces_color: Optional[str] = \"blue\"\n) -&gt; go.Figure:\n    # --- base trace ---\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Scatter(\n            x=main_trace.index.values,\n            y=main_trace.values,\n            mode=\"lines\",\n            name=main_trace.name,\n            line=dict(color=traces_color),\n            legendgroup=main_trace.name,\n        )\n    )\n\n    if main_trace_peak_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_peak_index],\n                y=[main_trace[main_trace_peak_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                name=f\"peak {main_trace.name}\",\n                opacity=0.5,\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_onset_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_onset_index],\n                y=[main_trace[main_trace_onset_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"onset {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_baseline_return_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_baseline_return_index],\n                y=[main_trace[main_trace_baseline_return_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"baseline return {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if additional_traces is not None:\n        for i, trace in enumerate(additional_traces):\n            fig.add_trace(\n                go.Scatter(\n                    x=trace.index.values,\n                    y=trace.values,\n                    mode=\"lines\",\n                    name=trace.name,\n                    opacity=0.15,\n                    line=dict(color=traces_color),\n                    legendgroup=trace.name,\n                )\n            )\n            if additional_traces_peak_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_peak_indexes[i]],\n                        y=[trace[additional_traces_peak_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                        name=f\"peak {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_onset_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_onset_indexes[i]],\n                        y=[trace[additional_traces_onset_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                        name=f\"onset {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_baseline_return_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_baseline_return_indexes[i]],\n                        y=[trace[additional_traces_baseline_return_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                        name=f\"baseline return {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n\n    if eflux_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = eflux_linear_coefficients.slope * x_vals + eflux_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"eflux={eflux_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    if influx_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = influx_linear_coefficients.slope * x_vals + influx_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"influx={influx_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    fig.update_layout(\n        title=title,\n        xaxis_title=xaxis_title,\n        yaxis_title=yaxis_title,\n        yaxis_range=yaxis_range if yaxis_range[1] &gt; main_trace.max() else (yaxis_range[0], main_trace.max() + 0.1),\n        template=\"plotly_white\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/calcium_imaging/#calcium_imaging.viz.plotly_color_iterator","title":"<code>plotly_color_iterator</code>","text":"Functions\u00b6 <code>get_n_colors_from_palette(n: int, palette_name: str = 'Plotly') -&gt; List[str]</code> \u00b6 Source code in <code>src\\calcium_imaging\\viz\\plotly_color_iterator.py</code> <pre><code>def get_n_colors_from_palette(n: int, palette_name: str = \"Plotly\") -&gt; List[str]:\n    color_iter = _get_color_iterator(palette_name)\n    return [next(color_iter) for _ in range(n)]\n</code></pre>"},{"location":"reference/calcium_imaging/instantiation/","title":"calcium_imaging.instantiation","text":""},{"location":"reference/calcium_imaging/instantiation/#calcium_imaging.instantiation","title":"<code>calcium_imaging.instantiation</code>","text":""},{"location":"reference/calcium_imaging/instantiation/#calcium_imaging.instantiation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/instantiation/#calcium_imaging.instantiation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/instantiation/#calcium_imaging.instantiation.load_experiment","title":"<code>load_experiment(experiment_dir: Union[str, Path], preprocessor: Preprocessor) -&gt; Experiment</code>","text":"<p>Reads an experiment directory and parses it into an Experiment class object</p> Source code in <code>src\\calcium_imaging\\instantiation.py</code> <pre><code>def load_experiment(experiment_dir: Union[str, Path], preprocessor: Preprocessor) -&gt; Experiment:\n    \"\"\"Reads an experiment directory and parses it into an Experiment class object\"\"\"\n    experiment_dir_path = validate_experiment_dir(experiment_dir)\n    coverslips = _instantiate_coverslips(experiment_dir_path, preprocessor)\n    groups = _instantiate_groups(coverslips)\n    experiment = _instantiate_experiment(\n        experiment_name=experiment_dir_path.stem,\n        groups=groups\n    )\n    return experiment\n</code></pre>"},{"location":"reference/calcium_imaging/instantiation/#calcium_imaging.instantiation-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/analysis/","title":"calcium_imaging.analysis","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis","title":"<code>calcium_imaging.analysis</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.baseline_return_detection","title":"<code>baseline_return_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.baseline_return_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.baseline_return_detection.detect_baseline_return_idx","title":"<code>detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int</code>","text":"<p>Detects the index where the trace crosses the eflux linear fit (returns to baseline). Args:     trace (pd.Series): The fluorescence trace.     eflux_start_idx (int): Start index for eflux. Returns:     int: Index where trace crosses the eflux linear fit.</p> Source code in <code>src\\calcium_imaging\\analysis\\baseline_return_detection.py</code> <pre><code>def detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int:\n    \"\"\"\n    Detects the index where the trace crosses the eflux linear fit (returns to baseline).\n    Args:\n        trace (pd.Series): The fluorescence trace.\n        eflux_start_idx (int): Start index for eflux.\n    Returns:\n        int: Index where trace crosses the eflux linear fit.\n    \"\"\"\n    for idx in range(eflux_start_idx, trace.index[-1], 1):\n        if trace.loc[idx] &lt;= 1:\n            return idx\n    return trace.index[-1]\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation","title":"<code>eflux_calculation</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.EFLUX_END_INDEX_MAX_OFFSET_FROM_START","title":"<code>EFLUX_END_INDEX_MAX_OFFSET_FROM_START = 30</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.EFLUX_END_INDEX_MIN_OFFSET_FROM_START","title":"<code>EFLUX_END_INDEX_MIN_OFFSET_FROM_START = 3</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.EFLUX_START_INDEX_OFFSET_FROM_PEAK","title":"<code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.calculate_eflux_linear_coefficients","title":"<code>calculate_eflux_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def calculate_eflux_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating eflux for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &gt;= 0:\n        print(f\"Warning: eflux is non-negative for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.detect_eflux_end_index","title":"<code>detect_eflux_end_index(trace: pd.Series) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_end_index(trace: pd.Series) -&gt; int:\n    start_idx = detect_eflux_start_index(trace)\n    end_idx = min(\n        start_idx + EFLUX_END_INDEX_MAX_OFFSET_FROM_START,\n        trace.index.values.max()  # prevent out of bounds\n    )\n    while end_idx &gt; start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START:\n        if trace.loc[end_idx] &gt;= 1.0:  # above baseline fluorescence level\n            return end_idx\n        end_idx -= 1\n    return end_idx  # start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.eflux_calculation.detect_eflux_start_index","title":"<code>detect_eflux_start_index(trace: pd.Series) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_start_index(trace: pd.Series) -&gt; int:\n    return detect_peak_index(trace) + EFLUX_START_INDEX_OFFSET_FROM_PEAK\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation","title":"<code>influx_calculation</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation.INFLUX_END_INDEX_OFFSET_FROM_PEAK","title":"<code>INFLUX_END_INDEX_OFFSET_FROM_PEAK = 1</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation.INFLUX_START_INDEX_MAX_OFFSET_FROM_END","title":"<code>INFLUX_START_INDEX_MAX_OFFSET_FROM_END = 60</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation.INFLUX_START_INDEX_MIN_OFFSET_FROM_END","title":"<code>INFLUX_START_INDEX_MIN_OFFSET_FROM_END = 2</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.influx_calculation.calculate_influx_linear_coefficients","title":"<code>calculate_influx_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\influx_calculation.py</code> <pre><code>def calculate_influx_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating influx for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &lt;= 0:\n        print(f\"Warning: influx is non-positive for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.linear_fit","title":"<code>linear_fit</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.linear_fit-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.linear_fit-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.linear_fit.linear_fit","title":"<code>linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\linear_fit.py</code> <pre><code>def linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D:\n    y = trace.loc[start_idx:end_idx]\n    x = y.index.to_numpy().astype(float)\n    regression_coefficients = RegressionCoefficients1D(*polyfit(x, y, deg=1))\n    return regression_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.onset_detection","title":"<code>onset_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.onset_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.onset_detection.detect_onset_index","title":"<code>detect_onset_index(trace: pd.Series, start_bound: int = 40, end_bound: int = 80, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code>","text":"<p>Detects the onset of a transient in a trace within a given window.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: index to start searching for the onset - end_bound: index to stop searching - baseline_window: number of points before start_bound to estimate baseline fluctuation - sliding_window: size of the moving average window (delta computed over this window) - threshold_factor: multiplier of baseline std to define onset</p> <p>Returns: - onset index (int) within bounds where signal \"explodes\"</p> Source code in <code>src\\calcium_imaging\\analysis\\onset_detection.py</code> <pre><code>def detect_onset_index(\n        trace: pd.Series,\n        start_bound: int = 40,\n        end_bound: int = 80,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects the onset of a transient in a trace within a given window.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: index to start searching for the onset\n    - end_bound: index to stop searching\n    - baseline_window: number of points before start_bound to estimate baseline fluctuation\n    - sliding_window: size of the moving average window (delta computed over this window)\n    - threshold_factor: multiplier of baseline std to define onset\n\n    Returns:\n    - onset index (int) within bounds where signal \"explodes\"\n    \"\"\"\n    if start_bound - baseline_window &lt; 0:\n        raise ValueError(\"Not enough data before start_bound to compute baseline\")\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_std = baseline.diff().dropna().abs().mean()\n\n    for i in range(start_bound, end_bound - sliding_window):\n        window = trace.iloc[i:i + sliding_window]\n        delta = window.diff().abs().mean()\n        if delta &gt; threshold_factor * baseline_std:\n            return trace.index[i]\n\n    print(f\"No onset detected within the specified bounds for trace: {trace.name}\")\n    return start_bound\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.peak_detection","title":"<code>peak_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.peak_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.peak_detection.detect_peak_index","title":"<code>detect_peak_index(trace: pd.Series, end_bound: int = 120, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code>","text":"<p>Detects a peak in a trace within the given bounds.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: start index for peak search - end_bound: end index for peak search - baseline_window: window size before start_bound to estimate noise level - sliding_window: how many points to consider when comparing local max - threshold_factor: peak must exceed baseline by this factor (std units)</p> <p>Returns: - Index of detected peak (int)</p> Source code in <code>src\\calcium_imaging\\analysis\\peak_detection.py</code> <pre><code>def detect_peak_index(\n        trace: pd.Series,\n        end_bound: int = 120,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects a peak in a trace within the given bounds.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: start index for peak search\n    - end_bound: end index for peak search\n    - baseline_window: window size before start_bound to estimate noise level\n    - sliding_window: how many points to consider when comparing local max\n    - threshold_factor: peak must exceed baseline by this factor (std units)\n\n    Returns:\n    - Index of detected peak (int)\n    \"\"\"\n    start_bound = detect_onset_index(trace)\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_mean = baseline.mean()\n    baseline_std = baseline.std()\n\n    for i in range(start_bound + sliding_window, end_bound - sliding_window):\n        current = trace.iloc[i]\n        neighbors = trace.iloc[i - sliding_window:i + sliding_window + 1]\n        if (current == neighbors.max() and\n                current &gt; baseline_mean + threshold_factor * baseline_std):\n            return trace.index[i]\n\n    # fallback\n    return trace.index.values[trace.argmax()]\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.regression_coefficients","title":"<code>regression_coefficients</code>","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.regression_coefficients-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/#calcium_imaging.analysis.regression_coefficients.RegressionCoefficients1D","title":"<code>RegressionCoefficients1D</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\analysis\\regression_coefficients.py</code> <pre><code>class RegressionCoefficients1D(NamedTuple):\n    intercept: float\n    slope: float\n</code></pre> Attributes\u00b6 <code>intercept: float</code> <code>instance-attribute</code> \u00b6 <code>slope: float</code> <code>instance-attribute</code> \u00b6"},{"location":"reference/calcium_imaging/analysis/baseline_return_detection/","title":"calcium_imaging.analysis.baseline_return_detection","text":""},{"location":"reference/calcium_imaging/analysis/baseline_return_detection/#calcium_imaging.analysis.baseline_return_detection","title":"<code>calcium_imaging.analysis.baseline_return_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/baseline_return_detection/#calcium_imaging.analysis.baseline_return_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/baseline_return_detection/#calcium_imaging.analysis.baseline_return_detection.detect_baseline_return_idx","title":"<code>detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int</code>","text":"<p>Detects the index where the trace crosses the eflux linear fit (returns to baseline). Args:     trace (pd.Series): The fluorescence trace.     eflux_start_idx (int): Start index for eflux. Returns:     int: Index where trace crosses the eflux linear fit.</p> Source code in <code>src\\calcium_imaging\\analysis\\baseline_return_detection.py</code> <pre><code>def detect_baseline_return_idx(trace: pd.Series, eflux_start_idx: int) -&gt; int:\n    \"\"\"\n    Detects the index where the trace crosses the eflux linear fit (returns to baseline).\n    Args:\n        trace (pd.Series): The fluorescence trace.\n        eflux_start_idx (int): Start index for eflux.\n    Returns:\n        int: Index where trace crosses the eflux linear fit.\n    \"\"\"\n    for idx in range(eflux_start_idx, trace.index[-1], 1):\n        if trace.loc[idx] &lt;= 1:\n            return idx\n    return trace.index[-1]\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/eflux_calculation/","title":"calcium_imaging.analysis.eflux_calculation","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation","title":"<code>calcium_imaging.analysis.eflux_calculation</code>","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.EFLUX_END_INDEX_MAX_OFFSET_FROM_START","title":"<code>EFLUX_END_INDEX_MAX_OFFSET_FROM_START = 30</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.EFLUX_END_INDEX_MIN_OFFSET_FROM_START","title":"<code>EFLUX_END_INDEX_MIN_OFFSET_FROM_START = 3</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.EFLUX_START_INDEX_OFFSET_FROM_PEAK","title":"<code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.calculate_eflux_linear_coefficients","title":"<code>calculate_eflux_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def calculate_eflux_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating eflux for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &gt;= 0:\n        print(f\"Warning: eflux is non-negative for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.detect_eflux_end_index","title":"<code>detect_eflux_end_index(trace: pd.Series) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_end_index(trace: pd.Series) -&gt; int:\n    start_idx = detect_eflux_start_index(trace)\n    end_idx = min(\n        start_idx + EFLUX_END_INDEX_MAX_OFFSET_FROM_START,\n        trace.index.values.max()  # prevent out of bounds\n    )\n    while end_idx &gt; start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START:\n        if trace.loc[end_idx] &gt;= 1.0:  # above baseline fluorescence level\n            return end_idx\n        end_idx -= 1\n    return end_idx  # start_idx + EFLUX_END_INDEX_MIN_OFFSET_FROM_START\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/eflux_calculation/#calcium_imaging.analysis.eflux_calculation.detect_eflux_start_index","title":"<code>detect_eflux_start_index(trace: pd.Series) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\eflux_calculation.py</code> <pre><code>def detect_eflux_start_index(trace: pd.Series) -&gt; int:\n    return detect_peak_index(trace) + EFLUX_START_INDEX_OFFSET_FROM_PEAK\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/influx_calculation/","title":"calcium_imaging.analysis.influx_calculation","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation","title":"<code>calcium_imaging.analysis.influx_calculation</code>","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation.INFLUX_END_INDEX_OFFSET_FROM_PEAK","title":"<code>INFLUX_END_INDEX_OFFSET_FROM_PEAK = 1</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation.INFLUX_START_INDEX_MAX_OFFSET_FROM_END","title":"<code>INFLUX_START_INDEX_MAX_OFFSET_FROM_END = 60</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation.INFLUX_START_INDEX_MIN_OFFSET_FROM_END","title":"<code>INFLUX_START_INDEX_MIN_OFFSET_FROM_END = 2</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/influx_calculation/#calcium_imaging.analysis.influx_calculation.calculate_influx_linear_coefficients","title":"<code>calculate_influx_linear_coefficients(trace: pd.Series, start_idx: Optional[int] = None, end_idx: Optional[int] = None) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\influx_calculation.py</code> <pre><code>def calculate_influx_linear_coefficients(\n        trace: pd.Series,\n        start_idx: Optional[int] = None,\n        end_idx: Optional[int] = None\n) -&gt; RegressionCoefficients1D:\n    if end_idx &lt;= start_idx:\n        raise RuntimeError(f\"error calculating influx for trace '{trace.name}', end_idx &lt;= start_idx\")\n    linear_coefficients = linear_fit(trace, start_idx, end_idx)\n    if linear_coefficients.slope &lt;= 0:\n        print(f\"Warning: influx is non-positive for trace '{trace.name}'\")\n    return linear_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/linear_fit/","title":"calcium_imaging.analysis.linear_fit","text":""},{"location":"reference/calcium_imaging/analysis/linear_fit/#calcium_imaging.analysis.linear_fit","title":"<code>calcium_imaging.analysis.linear_fit</code>","text":""},{"location":"reference/calcium_imaging/analysis/linear_fit/#calcium_imaging.analysis.linear_fit-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/linear_fit/#calcium_imaging.analysis.linear_fit-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/linear_fit/#calcium_imaging.analysis.linear_fit.linear_fit","title":"<code>linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D</code>","text":"Source code in <code>src\\calcium_imaging\\analysis\\linear_fit.py</code> <pre><code>def linear_fit(trace: pd.Series, start_idx: int, end_idx: int) -&gt; RegressionCoefficients1D:\n    y = trace.loc[start_idx:end_idx]\n    x = y.index.to_numpy().astype(float)\n    regression_coefficients = RegressionCoefficients1D(*polyfit(x, y, deg=1))\n    return regression_coefficients\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/onset_detection/","title":"calcium_imaging.analysis.onset_detection","text":""},{"location":"reference/calcium_imaging/analysis/onset_detection/#calcium_imaging.analysis.onset_detection","title":"<code>calcium_imaging.analysis.onset_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/onset_detection/#calcium_imaging.analysis.onset_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/onset_detection/#calcium_imaging.analysis.onset_detection.detect_onset_index","title":"<code>detect_onset_index(trace: pd.Series, start_bound: int = 40, end_bound: int = 80, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code>","text":"<p>Detects the onset of a transient in a trace within a given window.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: index to start searching for the onset - end_bound: index to stop searching - baseline_window: number of points before start_bound to estimate baseline fluctuation - sliding_window: size of the moving average window (delta computed over this window) - threshold_factor: multiplier of baseline std to define onset</p> <p>Returns: - onset index (int) within bounds where signal \"explodes\"</p> Source code in <code>src\\calcium_imaging\\analysis\\onset_detection.py</code> <pre><code>def detect_onset_index(\n        trace: pd.Series,\n        start_bound: int = 40,\n        end_bound: int = 80,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects the onset of a transient in a trace within a given window.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: index to start searching for the onset\n    - end_bound: index to stop searching\n    - baseline_window: number of points before start_bound to estimate baseline fluctuation\n    - sliding_window: size of the moving average window (delta computed over this window)\n    - threshold_factor: multiplier of baseline std to define onset\n\n    Returns:\n    - onset index (int) within bounds where signal \"explodes\"\n    \"\"\"\n    if start_bound - baseline_window &lt; 0:\n        raise ValueError(\"Not enough data before start_bound to compute baseline\")\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_std = baseline.diff().dropna().abs().mean()\n\n    for i in range(start_bound, end_bound - sliding_window):\n        window = trace.iloc[i:i + sliding_window]\n        delta = window.diff().abs().mean()\n        if delta &gt; threshold_factor * baseline_std:\n            return trace.index[i]\n\n    print(f\"No onset detected within the specified bounds for trace: {trace.name}\")\n    return start_bound\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/peak_detection/","title":"calcium_imaging.analysis.peak_detection","text":""},{"location":"reference/calcium_imaging/analysis/peak_detection/#calcium_imaging.analysis.peak_detection","title":"<code>calcium_imaging.analysis.peak_detection</code>","text":""},{"location":"reference/calcium_imaging/analysis/peak_detection/#calcium_imaging.analysis.peak_detection-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/analysis/peak_detection/#calcium_imaging.analysis.peak_detection.detect_peak_index","title":"<code>detect_peak_index(trace: pd.Series, end_bound: int = 120, baseline_window: int = 30, sliding_window: int = 3, threshold_factor: float = 3.0) -&gt; int</code>","text":"<p>Detects a peak in a trace within the given bounds.</p> <p>Parameters: - trace: pd.Series of numeric values - start_bound: start index for peak search - end_bound: end index for peak search - baseline_window: window size before start_bound to estimate noise level - sliding_window: how many points to consider when comparing local max - threshold_factor: peak must exceed baseline by this factor (std units)</p> <p>Returns: - Index of detected peak (int)</p> Source code in <code>src\\calcium_imaging\\analysis\\peak_detection.py</code> <pre><code>def detect_peak_index(\n        trace: pd.Series,\n        end_bound: int = 120,\n        baseline_window: int = 30,\n        sliding_window: int = 3,\n        threshold_factor: float = 3.0\n) -&gt; int:\n    \"\"\"\n    Detects a peak in a trace within the given bounds.\n\n    Parameters:\n    - trace: pd.Series of numeric values\n    - start_bound: start index for peak search\n    - end_bound: end index for peak search\n    - baseline_window: window size before start_bound to estimate noise level\n    - sliding_window: how many points to consider when comparing local max\n    - threshold_factor: peak must exceed baseline by this factor (std units)\n\n    Returns:\n    - Index of detected peak (int)\n    \"\"\"\n    start_bound = detect_onset_index(trace)\n\n    baseline = trace.iloc[start_bound - baseline_window:start_bound]\n    baseline_mean = baseline.mean()\n    baseline_std = baseline.std()\n\n    for i in range(start_bound + sliding_window, end_bound - sliding_window):\n        current = trace.iloc[i]\n        neighbors = trace.iloc[i - sliding_window:i + sliding_window + 1]\n        if (current == neighbors.max() and\n                current &gt; baseline_mean + threshold_factor * baseline_std):\n            return trace.index[i]\n\n    # fallback\n    return trace.index.values[trace.argmax()]\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/regression_coefficients/","title":"calcium_imaging.analysis.regression_coefficients","text":""},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients","title":"<code>calcium_imaging.analysis.regression_coefficients</code>","text":""},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients.RegressionCoefficients1D","title":"<code>RegressionCoefficients1D</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\analysis\\regression_coefficients.py</code> <pre><code>class RegressionCoefficients1D(NamedTuple):\n    intercept: float\n    slope: float\n</code></pre>"},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients.RegressionCoefficients1D-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients.RegressionCoefficients1D.intercept","title":"<code>intercept: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/analysis/regression_coefficients/#calcium_imaging.analysis.regression_coefficients.RegressionCoefficients1D.slope","title":"<code>slope: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/","title":"calcium_imaging.data_models","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models","title":"<code>calcium_imaging.data_models</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.coverslip","title":"<code>coverslip</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.coverslip-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.coverslip.Coverslip","title":"<code>Coverslip</code>","text":"<p>One plate</p> Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>class Coverslip:\n    \"\"\"One plate\"\"\"\n\n    def __init__(self, coverslip_id: int, group_type: str, rois: List[ROI]) -&gt; None:\n        self.rois = self._init_rois(rois)\n        self._id2roi = {roi.roi_id: roi for roi in self.rois}\n        self.id = coverslip_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.id}\"\n        self.title = f\"Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})\"\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, roi_id: int) -&gt; ROI:\n        return self._id2roi[roi_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.rois)\n\n    def __iter__(self) -&gt; Iterator[ROI]:\n        return iter(self.rois)\n\n    def drop_roi(self, roi_id: int) -&gt; None:\n        try:\n            self._id2roi.pop(roi_id)\n            self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n            print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n        except KeyError:\n            print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([roi.trace for roi in self.rois], axis=1)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for roi in self.rois]\n        rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n        rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"Coverslip {self.id} ({self.group_type})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n        mean_trace.name = f\"Coverslip {self.id} mean\"\n        return mean_trace\n\n    def _calculate_metric(\n            self,\n            metric_calculation_func: Callable[['ROI'], float],\n            metric_name: str,\n    ) -&gt; Union[List[float], List[Dict[str, float]]]:\n        return [\n            {\n                \"group_type\": self.group_type,\n                \"coverslip\": roi.coverslip_id,\n                \"roi\": roi.roi_id,\n                metric_name: metric_calculation_func(roi)\n            }\n            for roi in self.rois\n        ]\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_eflux(),\n            metric_name=\"eflux\",\n        )\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_amplitude(),\n            metric_name=\"amplitude\",\n        )\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_integral(),\n            metric_name=\"integral\",\n        )\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_tau(),\n            metric_name=\"tau\",\n        )\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n            print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n        for roi in self.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_rois(rois: List[ROI]) -&gt; List[ROI]:\n        rois = sorted(rois, key=lambda roi: roi.roi_id)\n        if len(rois) == 0:\n            raise ValueError(f\"Initializing class Coverslip with empty ROIs list is illegal.\")\n        if not all([roi.coverslip_id == rois[0].coverslip_id for roi in rois]):\n            raise ValueError(f\"All ROIs must share the same coverslip ID.\")\n        return rois\n</code></pre> Attributes\u00b6 <code>group_type = group_type</code> <code>instance-attribute</code> \u00b6 <code>id = coverslip_id</code> <code>instance-attribute</code> \u00b6 <code>name = f'cs-{self.id}'</code> <code>instance-attribute</code> \u00b6 <code>rois = self._init_rois(rois)</code> <code>instance-attribute</code> \u00b6 <code>title = f'Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n        print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n    for roi in self.rois:\n        roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_amplitude(),\n        metric_name=\"amplitude\",\n    )\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_eflux(),\n        metric_name=\"eflux\",\n    )\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_integral(),\n        metric_name=\"integral\",\n    )\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_tau(),\n        metric_name=\"tau\",\n    )\n</code></pre> <code>drop_roi(roi_id: int) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def drop_roi(self, roi_id: int) -&gt; None:\n    try:\n        self._id2roi.pop(roi_id)\n        self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n        print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n    except KeyError:\n        print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n</code></pre> <code>get_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([roi.trace for roi in self.rois], axis=1)\n</code></pre> <code>get_mean_trace() -&gt; pd.Series</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n    mean_trace.name = f\"Coverslip {self.id} mean\"\n    return mean_trace\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for roi in self.rois]\n    rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n    rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"Coverslip {self.id} ({self.group_type})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.coverslip-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.experiment","title":"<code>experiment</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.experiment-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>A folder containing multiple Conditions, e.g., 'SI_SH_check'.</p> Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>class Experiment:\n    \"\"\"A folder containing multiple Conditions, e.g., 'SI_SH_check'.\"\"\"\n\n    def __init__(self, name: str, groups: List[Group]) -&gt; None:\n        \"\"\"Holds multiple groups of the same experiment.\"\"\"\n        self.name = name\n        self.groups = sorted(groups, key=lambda g: g.group_type)\n        self._id2group = {g.group_type: g for g in self.groups}\n        self.num_groups = len(self.groups)\n        self.num_rois = len([roi for roi in self.iter_rois()])\n        self.title = f\"{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})\"\n\n    def __getitem__(self, group_type: str) -&gt; Group:\n        return self._id2group[group_type]\n\n    def __len__(self) -&gt; int:\n        return len(self.groups)\n\n    def __iter__(self) -&gt; Iterator[Group]:\n        return iter(self.groups)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def visualize(self) -&gt; None:\n        colors = get_n_colors_from_palette(self.num_groups)\n\n        all_traces = []\n        max_trace_val = 0\n        for color, group in zip(colors, self.groups):\n            rois_traces = [roi.trace for cs in group for roi in cs]\n            average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n            average_trace.name = f\"{group.group_type} mean\"\n            if average_trace.max() &gt; max_trace_val:\n                max_trace_val = average_trace.max()\n            group_fig = create_traces_figure(\n                main_trace=average_trace,\n                traces_color=color\n            )\n            all_traces.append(group_fig.data[0])\n\n        # Combine all traces into one figure\n        fig = go.Figure(data=all_traces)\n        fig.update_layout(\n            title=self.name,\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            xaxis=dict(showgrid=False),\n            yaxis=dict(showgrid=False),\n            template=\"plotly_white\",\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=1,\n                xanchor=\"left\",\n                x=1.05,\n                font=dict(size=10),\n                traceorder=\"normal\",\n            ),\n        )\n        fig.show()\n\n    def align_onsets(self) -&gt; None:\n        print(\"aligning onsets within each group\")\n        target_onsets = [group.align_onsets() for group in self.groups]\n        target_onset_idx = int(np.median(target_onsets))\n\n        print(f\"aligning onsets across groups to {target_onset_idx}\")\n        for group in self.groups:\n            group.align_onsets(target_onset_idx)\n\n    def get_mean_traces_df(self) -&gt; pd.DataFrame:\n        mean_traces = [group.get_mean_trace() for group in self.groups]\n        df = pd.concat(mean_traces, axis=1)\n        return df\n\n    def visualize_all_rois(self) -&gt; None:\n        for roi in self.iter_rois():\n            try:\n                roi.visualize()\n            except Exception as e:\n                print(e)\n                print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n\n    def run_manual_analysis(self) -&gt; None:\n        for i, roi in enumerate(self.iter_rois()):\n            try:\n                print(f\"ROI {i}/{self.num_rois}\")\n                self._ask_to_update_params(roi)\n            except Exception as e:\n                print(e)\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n                drop = get_bool_input(\"drop ROI? (y/n): \")\n                if drop:\n                    msg = f\"deleted {roi.title}\"\n                    del roi\n                    print(msg)\n                else:\n                    self._ask_to_update_params(roi)\n\n    @staticmethod\n    def _ask_to_update_params(roi: ROI):\n        while True:\n            roi.visualize()\n            peak_idx = get_int_input(f\"peak_idx={roi.peak_idx}, enter to accept or input to edit: \")\n            if peak_idx is not None:\n                roi.set_peak_idx(peak_idx)\n\n            onset_idx = get_int_input(f\"onset_idx={roi.onset_idx}, enter to accept or input to edit: \")\n            if onset_idx is not None:\n                roi.set_onset_idx(onset_idx)\n\n            if peak_idx is not None or onset_idx is not None:\n                roi.visualize()\n            else:\n                break\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for group in self.groups\n            for eflux_rate in group.calculate_eflux_rates()\n        ]\n\n    def _get_eflux_rates_df(self) -&gt; pd.DataFrame:\n        records = self.calculate_eflux_rates()\n        df = pd.DataFrame.from_records(records)\n        cols = df.columns.tolist()\n        df[\"experiment_name\"] = self.name\n        new_cols_order = [\"experiment_name\"] + cols\n        df = df[new_cols_order]\n        df = df.sort_values(by=[\"coverslip\", \"roi\"], ascending=True)\n        return df\n\n    def visualize_eflux_bar_chart(self) -&gt; None:\n        df = self._get_eflux_rates_df()\n        group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n        # Compute SEM and 95% CI (approx)\n        group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n        group_stats['ci95'] = 1.96 * group_stats['sem']\n\n        # Plot with 95% CI as error bars\n        fig = go.Figure([\n            go.Bar(\n                x=group_stats.index,\n                y=group_stats['mean'],\n                error_y=dict(type='data', array=group_stats['ci95']),\n                name='Mean \u00b1 95% CI'\n            )\n        ])\n        fig.update_layout(\n            title=\"Eflux mean with 95% Confidence Interval\",\n            xaxis_title=\"Group Type\",\n            yaxis_title=\"Eflux\",\n            template=\"plotly_white\"\n        )\n        fig.show()\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for group in self.groups\n            for amplitude in group.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for group in self.groups\n            for integral in group.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for group in self.groups\n            for tau in group.calculate_taus()\n        ]\n\n    def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n        return {g.group_type: g.get_df() for g in self.groups}\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n        for group_type, df in self.get_group_type_to_df().items():\n            base = results_output_dir_path / group_type\n            df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n            df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n\n    def iter_rois(self) -&gt; Iterator[ROI]:\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    yield roi\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        records = []\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    try:\n                        eflux = roi.calculate_eflux()\n                    except RuntimeError:\n                        eflux = np.nan\n\n                    try:\n                        influx = roi.calculate_influx()\n                    except RuntimeError:\n                        influx = np.nan\n\n                    try:\n                        amplitude = roi.calculate_amplitude()\n                    except RuntimeError:\n                        amplitude = np.nan\n\n                    try:\n                        integral = roi.calculate_integral()\n                    except RuntimeError:\n                        integral = np.nan\n\n                    try:\n                        tau = roi.calculate_tau()\n                    except RuntimeError:\n                        tau = np.nan\n\n                    records.append({\n                        \"experiment_name\": self.name,\n                        \"group_type\": group.group_type,\n                        \"coverslip\": coverslip.id,\n                        \"roi\": roi.roi_id,\n                        \"onset_frame\": roi.onset_idx,\n                        \"peak_frame\": roi.peak_idx,\n                        \"eflux\": eflux,\n                        \"influx\": influx,\n                        \"amplitude\": amplitude,\n                        \"integral\": integral,\n                        \"tau\": tau,\n                    })\n\n        df = pd.DataFrame.from_records(records)\n        df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n</code></pre> Attributes\u00b6 <code>groups = sorted(groups, key=lambda g: g.group_type)</code> <code>instance-attribute</code> \u00b6 <code>name = name</code> <code>instance-attribute</code> \u00b6 <code>num_groups = len(self.groups)</code> <code>instance-attribute</code> \u00b6 <code>num_rois = len([roi for roi in self.iter_rois()])</code> <code>instance-attribute</code> \u00b6 <code>title = f'{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def align_onsets(self) -&gt; None:\n    print(\"aligning onsets within each group\")\n    target_onsets = [group.align_onsets() for group in self.groups]\n    target_onset_idx = int(np.median(target_onsets))\n\n    print(f\"aligning onsets across groups to {target_onset_idx}\")\n    for group in self.groups:\n        group.align_onsets(target_onset_idx)\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for group in self.groups\n        for amplitude in group.calculate_amplitudes()\n    ]\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for group in self.groups\n        for eflux_rate in group.calculate_eflux_rates()\n    ]\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for group in self.groups\n        for integral in group.calculate_integrals()\n    ]\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for group in self.groups\n        for tau in group.calculate_taus()\n    ]\n</code></pre> <code>get_full_analysis_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    records = []\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                try:\n                    eflux = roi.calculate_eflux()\n                except RuntimeError:\n                    eflux = np.nan\n\n                try:\n                    influx = roi.calculate_influx()\n                except RuntimeError:\n                    influx = np.nan\n\n                try:\n                    amplitude = roi.calculate_amplitude()\n                except RuntimeError:\n                    amplitude = np.nan\n\n                try:\n                    integral = roi.calculate_integral()\n                except RuntimeError:\n                    integral = np.nan\n\n                try:\n                    tau = roi.calculate_tau()\n                except RuntimeError:\n                    tau = np.nan\n\n                records.append({\n                    \"experiment_name\": self.name,\n                    \"group_type\": group.group_type,\n                    \"coverslip\": coverslip.id,\n                    \"roi\": roi.roi_id,\n                    \"onset_frame\": roi.onset_idx,\n                    \"peak_frame\": roi.peak_idx,\n                    \"eflux\": eflux,\n                    \"influx\": influx,\n                    \"amplitude\": amplitude,\n                    \"integral\": integral,\n                    \"tau\": tau,\n                })\n\n    df = pd.DataFrame.from_records(records)\n    df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre> <code>get_group_type_to_df() -&gt; Dict[str, pd.DataFrame]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n    return {g.group_type: g.get_df() for g in self.groups}\n</code></pre> <code>get_mean_traces_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_mean_traces_df(self) -&gt; pd.DataFrame:\n    mean_traces = [group.get_mean_trace() for group in self.groups]\n    df = pd.concat(mean_traces, axis=1)\n    return df\n</code></pre> <code>iter_rois() -&gt; Iterator[ROI]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def iter_rois(self) -&gt; Iterator[ROI]:\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                yield roi\n</code></pre> <code>run_manual_analysis() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def run_manual_analysis(self) -&gt; None:\n    for i, roi in enumerate(self.iter_rois()):\n        try:\n            print(f\"ROI {i}/{self.num_rois}\")\n            self._ask_to_update_params(roi)\n        except Exception as e:\n            print(e)\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n            drop = get_bool_input(\"drop ROI? (y/n): \")\n            if drop:\n                msg = f\"deleted {roi.title}\"\n                del roi\n                print(msg)\n            else:\n                self._ask_to_update_params(roi)\n</code></pre> <code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n    for group_type, df in self.get_group_type_to_df().items():\n        base = results_output_dir_path / group_type\n        df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n</code></pre> <code>visualize() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize(self) -&gt; None:\n    colors = get_n_colors_from_palette(self.num_groups)\n\n    all_traces = []\n    max_trace_val = 0\n    for color, group in zip(colors, self.groups):\n        rois_traces = [roi.trace for cs in group for roi in cs]\n        average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n        average_trace.name = f\"{group.group_type} mean\"\n        if average_trace.max() &gt; max_trace_val:\n            max_trace_val = average_trace.max()\n        group_fig = create_traces_figure(\n            main_trace=average_trace,\n            traces_color=color\n        )\n        all_traces.append(group_fig.data[0])\n\n    # Combine all traces into one figure\n    fig = go.Figure(data=all_traces)\n    fig.update_layout(\n        title=self.name,\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        template=\"plotly_white\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n    fig.show()\n</code></pre> <code>visualize_all_rois() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_all_rois(self) -&gt; None:\n    for roi in self.iter_rois():\n        try:\n            roi.visualize()\n        except Exception as e:\n            print(e)\n            print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n</code></pre> <code>visualize_eflux_bar_chart() -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_eflux_bar_chart(self) -&gt; None:\n    df = self._get_eflux_rates_df()\n    group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n    # Compute SEM and 95% CI (approx)\n    group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n    group_stats['ci95'] = 1.96 * group_stats['sem']\n\n    # Plot with 95% CI as error bars\n    fig = go.Figure([\n        go.Bar(\n            x=group_stats.index,\n            y=group_stats['mean'],\n            error_y=dict(type='data', array=group_stats['ci95']),\n            name='Mean \u00b1 95% CI'\n        )\n    ])\n    fig.update_layout(\n        title=\"Eflux mean with 95% Confidence Interval\",\n        xaxis_title=\"Group Type\",\n        yaxis_title=\"Eflux\",\n        template=\"plotly_white\"\n    )\n    fig.show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.experiment-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.experiment-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.group","title":"<code>group</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.group-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.group.Group","title":"<code>Group</code>","text":"<p>One group with certain intervention, e.g. 'shNCLX'.</p> Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>class Group:\n    \"\"\"One group with certain intervention, e.g. 'shNCLX'.\"\"\"\n\n    def __init__(self, coverslips: List[Coverslip]) -&gt; None:\n        \"\"\"Holds multiple runs of the same group\"\"\"\n        self.coverslips = self._init_coverslips(coverslips)\n        self._id2coverslip = {cs.id: cs for cs in self.coverslips}\n        self.group_type = self._infer_group_type()\n        self.title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, coverslip_id: int) -&gt; Coverslip:\n        return self._id2coverslip[coverslip_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.coverslips)\n\n    def __iter__(self) -&gt; Iterator[Coverslip]:\n        return iter(self.coverslips)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n        rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n        rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n        mean_trace.name = f\"{self.group_type} mean\"\n        return mean_trace\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for cs in self.coverslips\n            for eflux_rate in cs.calculate_eflux_rates()\n        ]\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for cs in self.coverslips\n            for amplitude in cs.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for cs in self.coverslips\n            for integral in cs.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for cs in self.coverslips\n            for tau in cs.calculate_taus()\n        ]\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n            target_onset_idx = int(np.median(onset_indexes))\n            print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n        for coverslip in self.coverslips:\n            for roi in coverslip.rois:\n                roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_coverslips(coverslips: List[Coverslip]) -&gt; List[Coverslip]:\n        coverslips = sorted(coverslips, key=lambda cs: cs.id)\n        if len(coverslips) == 0:\n            raise ValueError(f\"Initializing class Group with empty Coverslips list is illegal.\")\n        if not all([cs.group_type == coverslips[0].group_type for cs in coverslips]):\n            raise ValueError(f\"All Coverslips must share the same group type.\")\n        return coverslips\n\n    def _infer_group_type(self) -&gt; str:\n        return self.coverslips[0].group_type\n</code></pre> Attributes\u00b6 <code>coverslips = self._init_coverslips(coverslips)</code> <code>instance-attribute</code> \u00b6 <code>group_type = self._infer_group_type()</code> <code>instance-attribute</code> \u00b6 <code>title = f'{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        target_onset_idx = int(np.median(onset_indexes))\n        print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n    for coverslip in self.coverslips:\n        for roi in coverslip.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre> <code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for cs in self.coverslips\n        for amplitude in cs.calculate_amplitudes()\n    ]\n</code></pre> <code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for cs in self.coverslips\n        for eflux_rate in cs.calculate_eflux_rates()\n    ]\n</code></pre> <code>calculate_integrals() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for cs in self.coverslips\n        for integral in cs.calculate_integrals()\n    ]\n</code></pre> <code>calculate_taus() -&gt; List[Dict[str, float]]</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for cs in self.coverslips\n        for tau in cs.calculate_taus()\n    ]\n</code></pre> <code>get_df() -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n</code></pre> <code>get_mean_trace() -&gt; pd.Series</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n    mean_trace.name = f\"{self.group_type} mean\"\n    return mean_trace\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n    rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n    rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.group-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.research","title":"<code>research</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.research-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.research.Research","title":"<code>Research</code>","text":"<p>A collection of multiple experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>class Research:\n    \"\"\"A collection of multiple experiments.\"\"\"\n\n    def __init__(self, name: str, experiments: List[Experiment]) -&gt; None:\n        \"\"\"Holds multiple experiments of the same research project.\"\"\"\n        self.name = name\n        self.experiments = sorted(experiments, key=lambda e: e.name)\n        self._id2experiment = {e.name: e for e in self.experiments}\n        self.num_experiments = len(self.experiments)\n        self.num_groups = sum(e.num_groups for e in self.experiments)\n        self.num_rois = sum(e.num_rois for e in self.experiments)\n        self.title = f\"{name} (Experiments {', '.join([e.name for e in self.experiments])})\"\n\n    def __getitem__(self, experiment_name: str) -&gt; Experiment:\n        return self._id2experiment[experiment_name]\n\n    def __len__(self) -&gt; int:\n        return len(self.experiments)\n\n    def __iter__(self) -&gt; Iterator[Experiment]:\n        return iter(self.experiments)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n        dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n        df = pd.concat(dfs, axis=0)\n        df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n        \"\"\"Save analysis results for all experiments.\"\"\"\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Save individual experiment results\n        for experiment in self.experiments:\n            experiment.save_mega_dfs(results_output_dir_path)\n\n        # Save combined results\n        combined_df = self.get_full_analysis_df()\n        base = results_output_dir_path / \"combined_analysis\"\n        combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre> Attributes\u00b6 <code>experiments = sorted(experiments, key=lambda e: e.name)</code> <code>instance-attribute</code> \u00b6 <code>name = name</code> <code>instance-attribute</code> \u00b6 <code>num_experiments = len(self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>num_groups = sum(e.num_groups for e in self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>num_rois = sum(e.num_rois for e in self.experiments)</code> <code>instance-attribute</code> \u00b6 <code>title = f'{name} (Experiments {', '.join([e.name for e in self.experiments])})'</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>get_full_analysis_df() -&gt; pd.DataFrame</code> \u00b6 <p>Get a combined DataFrame of all experiments' analysis results.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n    dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n    df = pd.concat(dfs, axis=0)\n    df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre> <code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code> \u00b6 <p>Save analysis results for all experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n    \"\"\"Save analysis results for all experiments.\"\"\"\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n    # Save individual experiment results\n    for experiment in self.experiments:\n        experiment.save_mega_dfs(results_output_dir_path)\n\n    # Save combined results\n    combined_df = self.get_full_analysis_df()\n    base = results_output_dir_path / \"combined_analysis\"\n    combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n    combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.roi","title":"<code>roi</code>","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.roi-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.roi.ROI","title":"<code>ROI</code>","text":"<p>A class representing a single region of interest (ROI) in calcium imaging data.</p> <p>This class handles the analysis and visualization of calcium imaging data for a single ROI, including calculation of influx/eflux rates, amplitude, integral, and tau values.</p> <p>Attributes:</p> Name Type Description <code>coverslip_id</code> <code>int</code> <p>The ID of the coverslip this ROI belongs to.</p> <code>roi_id</code> <code>int</code> <p>The unique identifier for this ROI.</p> <code>group_type</code> <code>str</code> <p>The type of group this ROI belongs to.</p> <code>name</code> <code>str</code> <p>A formatted name combining coverslip and ROI IDs.</p> <code>title</code> <code>str</code> <p>A descriptive title for the ROI.</p> <code>time</code> <code>Series</code> <p>Time series data for the ROI.</p> <code>trace</code> <code>Series</code> <p>Fluorescence trace data for the ROI.</p> <code>onset_idx</code> <code>int</code> <p>Index of the onset of the calcium response.</p> <code>peak_idx</code> <code>int</code> <p>Index of the peak of the calcium response.</p> <code>influx_start_idx</code> <code>int</code> <p>Start index for influx calculation.</p> <code>influx_end_idx</code> <code>int</code> <p>End index for influx calculation.</p> <code>eflux_start_idx</code> <code>int</code> <p>Start index for eflux calculation.</p> <code>eflux_end_idx</code> <code>int</code> <p>End index for eflux calculation.</p> <code>baseline_return_idx</code> <code>int</code> <p>Index where the trace returns to baseline.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>class ROI:\n    \"\"\"A class representing a single region of interest (ROI) in calcium imaging data.\n\n    This class handles the analysis and visualization of calcium imaging data for a single ROI,\n    including calculation of influx/eflux rates, amplitude, integral, and tau values.\n\n    Attributes:\n        coverslip_id (int): The ID of the coverslip this ROI belongs to.\n        roi_id (int): The unique identifier for this ROI.\n        group_type (str): The type of group this ROI belongs to.\n        name (str): A formatted name combining coverslip and ROI IDs.\n        title (str): A descriptive title for the ROI.\n        time (pd.Series): Time series data for the ROI.\n        trace (pd.Series): Fluorescence trace data for the ROI.\n        onset_idx (int): Index of the onset of the calcium response.\n        peak_idx (int): Index of the peak of the calcium response.\n        influx_start_idx (int): Start index for influx calculation.\n        influx_end_idx (int): End index for influx calculation.\n        eflux_start_idx (int): Start index for eflux calculation.\n        eflux_end_idx (int): End index for eflux calculation.\n        baseline_return_idx (int): Index where the trace returns to baseline.\n    \"\"\"\n    EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5\n\n    def __init__(\n            self,\n            trace: pd.Series,\n            time: pd.Series,\n            roi_id: int,\n            coverslip_id: int,\n            group_type: str,\n    ) -&gt; None:\n        \"\"\"Initialize a new ROI instance.\n\n        Args:\n            trace (pd.Series): The fluorescence trace data for this ROI.\n            time (pd.Series): The time series data corresponding to the trace.\n            roi_id (int): The unique identifier for this ROI.\n            coverslip_id (int): The ID of the coverslip this ROI belongs to.\n            group_type (str): The type of group this ROI belongs to.\n        \"\"\"\n        self.coverslip_id = coverslip_id\n        self.roi_id = roi_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.coverslip_id}_roi-{self.roi_id}\"\n        self.title = f\"ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})\"\n        self.time = time.copy(deep=True).rename(f\"time_{self.name}\")\n        self.trace = trace.copy(deep=True).rename(self.name)\n        self.onset_idx = detect_onset_index(self.trace)\n        self.peak_idx = detect_peak_index(self.trace)\n        self.influx_start_idx = self.onset_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.eflux_end_idx = detect_eflux_end_index(self.trace)\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def shift_trace(self, periods: int) -&gt; None:\n        \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n        Args:\n            periods (int): Number of periods to shift the trace and indices.\n        \"\"\"\n        self.time = self.time.shift(periods)\n        self.trace = self.trace.shift(periods)\n        self.onset_idx = self.onset_idx + periods\n        self.peak_idx = self.peak_idx + periods\n        self.influx_start_idx = self.influx_start_idx + periods\n        self.influx_end_idx = self.influx_end_idx + periods\n        self.eflux_start_idx = self.eflux_start_idx + periods\n        self.eflux_end_idx = self.eflux_end_idx + periods\n        self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n\n    def calculate_influx(self) -&gt; float:\n        \"\"\"Calculate the influx rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated influx rate.\n        \"\"\"\n        return calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        ).slope\n\n    def calculate_eflux(self) -&gt; float:\n        \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated eflux rate.\n        \"\"\"\n        return calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        ).slope\n\n    def calculate_amplitude(self) -&gt; float:\n        \"\"\"Calculate the amplitude of the calcium response.\n\n        Returns:\n            float: The amplitude, calculated as the peak value minus 1.\n        \"\"\"\n        return self.trace[self.peak_idx] - 1\n\n    def calculate_integral(self) -&gt; float:\n        \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n        Returns:\n            float: The calculated integral of the trace.\n\n        Raises:\n            ValueError: If baseline_return_idx is not set (equals -999).\n        \"\"\"\n        # Get the relevant portions of the trace and time series\n        trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n        time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n        # Calculate integral using trapezoidal rule\n        integral = np.trapz(trace_segment, time_segment)\n        return integral\n\n    def calculate_tau(self) -&gt; float:\n        \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n        Tau is calculated as the time between the peak and when the trace reaches\n        63.2% of the amplitude decay from peak.\n\n        Returns:\n            float: The calculated tau value.\n        \"\"\"\n        peak_value = self.trace[self.peak_idx]\n        target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n        # Search forward from peak to find where trace crosses target value\n        for idx in range(self.peak_idx, len(self.trace)):\n            if self.trace.loc[idx] &lt;= target_value:\n                return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n        return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n        Args:\n            title_prefix (Optional[str]): Optional prefix to add to the plot title.\n        \"\"\"\n        influx_linear_coefficients = calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        )\n        eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        )\n        create_traces_figure(\n            main_trace=self.trace,\n            title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            main_trace_peak_index=self.peak_idx,\n            main_trace_onset_index=self.onset_idx,\n            main_trace_baseline_return_index=self.baseline_return_idx,\n            eflux_linear_coefficients=eflux_linear_coefficients,\n            influx_linear_coefficients=influx_linear_coefficients\n        ).show()\n\n    def set_peak_idx(self, peak_idx: int) -&gt; None:\n        \"\"\"Set a new peak index and update related indices.\n\n        Args:\n            peak_idx (int): The new peak index to set.\n        \"\"\"\n        self.peak_idx = peak_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def set_onset_idx(self, onset_idx: int) -&gt; None:\n        \"\"\"Set a new onset index and update related indices.\n\n        Args:\n            onset_idx (int): The new onset index to set.\n        \"\"\"\n        self.onset_idx = onset_idx\n        self.influx_start_idx = self.onset_idx\n\n    def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n        \"\"\"Set a new baseline return index.\n\n        Args:\n            baseline_return_idx (int): The new baseline return index to set.\n        \"\"\"\n        self.baseline_return_idx = baseline_return_idx\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the ROI.\n\n        Returns:\n            str: A string containing the ROI's title.\n        \"\"\"\n        return self.title\n</code></pre> Attributes\u00b6 <code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code> <code>class-attribute</code> <code>instance-attribute</code> \u00b6 <code>baseline_return_idx = detect_baseline_return_idx(self.trace, self.eflux_start_idx)</code> <code>instance-attribute</code> \u00b6 <code>coverslip_id = coverslip_id</code> <code>instance-attribute</code> \u00b6 <code>eflux_end_idx = detect_eflux_end_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK</code> <code>instance-attribute</code> \u00b6 <code>group_type = group_type</code> <code>instance-attribute</code> \u00b6 <code>influx_end_idx = self.peak_idx</code> <code>instance-attribute</code> \u00b6 <code>influx_start_idx = self.onset_idx</code> <code>instance-attribute</code> \u00b6 <code>name = f'cs-{self.coverslip_id}_roi-{self.roi_id}'</code> <code>instance-attribute</code> \u00b6 <code>onset_idx = detect_onset_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>peak_idx = detect_peak_index(self.trace)</code> <code>instance-attribute</code> \u00b6 <code>roi_id = roi_id</code> <code>instance-attribute</code> \u00b6 <code>time = time.copy(deep=True).rename(f'time_{self.name}')</code> <code>instance-attribute</code> \u00b6 <code>title = f'ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})'</code> <code>instance-attribute</code> \u00b6 <code>trace = trace.copy(deep=True).rename(self.name)</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>calculate_amplitude() -&gt; float</code> \u00b6 <p>Calculate the amplitude of the calcium response.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The amplitude, calculated as the peak value minus 1.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_amplitude(self) -&gt; float:\n    \"\"\"Calculate the amplitude of the calcium response.\n\n    Returns:\n        float: The amplitude, calculated as the peak value minus 1.\n    \"\"\"\n    return self.trace[self.peak_idx] - 1\n</code></pre> <code>calculate_eflux() -&gt; float</code> \u00b6 <p>Calculate the eflux rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated eflux rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_eflux(self) -&gt; float:\n    \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated eflux rate.\n    \"\"\"\n    return calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    ).slope\n</code></pre> <code>calculate_influx() -&gt; float</code> \u00b6 <p>Calculate the influx rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated influx rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_influx(self) -&gt; float:\n    \"\"\"Calculate the influx rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated influx rate.\n    \"\"\"\n    return calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    ).slope\n</code></pre> <code>calculate_integral() -&gt; float</code> \u00b6 <p>Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated integral of the trace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If baseline_return_idx is not set (equals -999).</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_integral(self) -&gt; float:\n    \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n    Returns:\n        float: The calculated integral of the trace.\n\n    Raises:\n        ValueError: If baseline_return_idx is not set (equals -999).\n    \"\"\"\n    # Get the relevant portions of the trace and time series\n    trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n    time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n    # Calculate integral using trapezoidal rule\n    integral = np.trapz(trace_segment, time_segment)\n    return integral\n</code></pre> <code>calculate_tau() -&gt; float</code> \u00b6 <p>Calculate the time constant (tau) of the calcium response decay.</p> <p>Tau is calculated as the time between the peak and when the trace reaches 63.2% of the amplitude decay from peak.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated tau value.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_tau(self) -&gt; float:\n    \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n    Tau is calculated as the time between the peak and when the trace reaches\n    63.2% of the amplitude decay from peak.\n\n    Returns:\n        float: The calculated tau value.\n    \"\"\"\n    peak_value = self.trace[self.peak_idx]\n    target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n    # Search forward from peak to find where trace crosses target value\n    for idx in range(self.peak_idx, len(self.trace)):\n        if self.trace.loc[idx] &lt;= target_value:\n            return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n    return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n</code></pre> <code>set_baseline_return_idx(baseline_return_idx: int) -&gt; None</code> \u00b6 <p>Set a new baseline return index.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_return_idx</code> <code>int</code> <p>The new baseline return index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n    \"\"\"Set a new baseline return index.\n\n    Args:\n        baseline_return_idx (int): The new baseline return index to set.\n    \"\"\"\n    self.baseline_return_idx = baseline_return_idx\n</code></pre> <code>set_onset_idx(onset_idx: int) -&gt; None</code> \u00b6 <p>Set a new onset index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>onset_idx</code> <code>int</code> <p>The new onset index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_onset_idx(self, onset_idx: int) -&gt; None:\n    \"\"\"Set a new onset index and update related indices.\n\n    Args:\n        onset_idx (int): The new onset index to set.\n    \"\"\"\n    self.onset_idx = onset_idx\n    self.influx_start_idx = self.onset_idx\n</code></pre> <code>set_peak_idx(peak_idx: int) -&gt; None</code> \u00b6 <p>Set a new peak index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>peak_idx</code> <code>int</code> <p>The new peak index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_peak_idx(self, peak_idx: int) -&gt; None:\n    \"\"\"Set a new peak index and update related indices.\n\n    Args:\n        peak_idx (int): The new peak index to set.\n    \"\"\"\n    self.peak_idx = peak_idx\n    self.influx_end_idx = self.peak_idx\n    self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n    self.baseline_return_idx = detect_baseline_return_idx(\n        self.trace, self.eflux_start_idx\n    )\n</code></pre> <code>shift_trace(periods: int) -&gt; None</code> \u00b6 <p>Shift the trace and all associated indices by a specified number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to shift the trace and indices.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def shift_trace(self, periods: int) -&gt; None:\n    \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n    Args:\n        periods (int): Number of periods to shift the trace and indices.\n    \"\"\"\n    self.time = self.time.shift(periods)\n    self.trace = self.trace.shift(periods)\n    self.onset_idx = self.onset_idx + periods\n    self.peak_idx = self.peak_idx + periods\n    self.influx_start_idx = self.influx_start_idx + periods\n    self.influx_end_idx = self.influx_end_idx + periods\n    self.eflux_start_idx = self.eflux_start_idx + periods\n    self.eflux_end_idx = self.eflux_end_idx + periods\n    self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n</code></pre> <code>visualize(title_prefix: Optional[str] = None) -&gt; None</code> \u00b6 <p>Create and display a visualization of the ROI trace with key points marked.</p> <p>Parameters:</p> Name Type Description Default <code>title_prefix</code> <code>Optional[str]</code> <p>Optional prefix to add to the plot title.</p> <code>None</code> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n    Args:\n        title_prefix (Optional[str]): Optional prefix to add to the plot title.\n    \"\"\"\n    influx_linear_coefficients = calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    )\n    eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    )\n    create_traces_figure(\n        main_trace=self.trace,\n        title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        main_trace_peak_index=self.peak_idx,\n        main_trace_onset_index=self.onset_idx,\n        main_trace_baseline_return_index=self.baseline_return_idx,\n        eflux_linear_coefficients=eflux_linear_coefficients,\n        influx_linear_coefficients=influx_linear_coefficients\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/#calcium_imaging.data_models.roi-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/","title":"calcium_imaging.data_models.coverslip","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip","title":"<code>calcium_imaging.data_models.coverslip</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip","title":"<code>Coverslip</code>","text":"<p>One plate</p> Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>class Coverslip:\n    \"\"\"One plate\"\"\"\n\n    def __init__(self, coverslip_id: int, group_type: str, rois: List[ROI]) -&gt; None:\n        self.rois = self._init_rois(rois)\n        self._id2roi = {roi.roi_id: roi for roi in self.rois}\n        self.id = coverslip_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.id}\"\n        self.title = f\"Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})\"\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, roi_id: int) -&gt; ROI:\n        return self._id2roi[roi_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.rois)\n\n    def __iter__(self) -&gt; Iterator[ROI]:\n        return iter(self.rois)\n\n    def drop_roi(self, roi_id: int) -&gt; None:\n        try:\n            self._id2roi.pop(roi_id)\n            self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n            print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n        except KeyError:\n            print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([roi.trace for roi in self.rois], axis=1)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for roi in self.rois]\n        rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n        rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"Coverslip {self.id} ({self.group_type})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n        mean_trace.name = f\"Coverslip {self.id} mean\"\n        return mean_trace\n\n    def _calculate_metric(\n            self,\n            metric_calculation_func: Callable[['ROI'], float],\n            metric_name: str,\n    ) -&gt; Union[List[float], List[Dict[str, float]]]:\n        return [\n            {\n                \"group_type\": self.group_type,\n                \"coverslip\": roi.coverslip_id,\n                \"roi\": roi.roi_id,\n                metric_name: metric_calculation_func(roi)\n            }\n            for roi in self.rois\n        ]\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_eflux(),\n            metric_name=\"eflux\",\n        )\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_amplitude(),\n            metric_name=\"amplitude\",\n        )\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_integral(),\n            metric_name=\"integral\",\n        )\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return self._calculate_metric(\n            lambda roi: roi.calculate_tau(),\n            metric_name=\"tau\",\n        )\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n            print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n        for roi in self.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_rois(rois: List[ROI]) -&gt; List[ROI]:\n        rois = sorted(rois, key=lambda roi: roi.roi_id)\n        if len(rois) == 0:\n            raise ValueError(f\"Initializing class Coverslip with empty ROIs list is illegal.\")\n        if not all([roi.coverslip_id == rois[0].coverslip_id for roi in rois]):\n            raise ValueError(f\"All ROIs must share the same coverslip ID.\")\n        return rois\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.group_type","title":"<code>group_type = group_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.id","title":"<code>id = coverslip_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.name","title":"<code>name = f'cs-{self.id}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.rois","title":"<code>rois = self._init_rois(rois)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.title","title":"<code>title = f'Coverslip {self.id} (ROIs {', '.join(str(roi.roi_id) for roi in self.rois)})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.align_onsets","title":"<code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        target_onset_idx = int(np.median([roi.onset_idx for roi in self.rois]))\n        print(f\"aligning {len(self.rois)} ROIs to {target_onset_idx}\")\n    for roi in self.rois:\n        roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_amplitude(),\n        metric_name=\"amplitude\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_eflux(),\n        metric_name=\"eflux\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_integral(),\n        metric_name=\"integral\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return self._calculate_metric(\n        lambda roi: roi.calculate_tau(),\n        metric_name=\"tau\",\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.drop_roi","title":"<code>drop_roi(roi_id: int) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def drop_roi(self, roi_id: int) -&gt; None:\n    try:\n        self._id2roi.pop(roi_id)\n        self.rois = [roi for roi in self.rois if roi.roi_id != roi_id]\n        print(f\"Successfully dropped ROI {roi_id} from Coverslip {self.id}\")\n    except KeyError:\n        print(f\"ROI with id {roi_id} not found in '{self.name}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.get_df","title":"<code>get_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([roi.trace for roi in self.rois], axis=1)\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.get_mean_trace","title":"<code>get_mean_trace() -&gt; pd.Series</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for roi in self.rois], axis=1).mean(axis=1))\n    mean_trace.name = f\"Coverslip {self.id} mean\"\n    return mean_trace\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip.Coverslip.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\coverslip.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for roi in self.rois]\n    rois_peak_indexes = [roi.peak_idx for roi in self.rois]\n    rois_onset_indexes = [roi.onset_idx for roi in self.rois]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for roi in self.rois]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"Coverslip {self.id} ({self.group_type})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/coverslip/#calcium_imaging.data_models.coverslip-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/experiment/","title":"calcium_imaging.data_models.experiment","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment","title":"<code>calcium_imaging.data_models.experiment</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>A folder containing multiple Conditions, e.g., 'SI_SH_check'.</p> Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>class Experiment:\n    \"\"\"A folder containing multiple Conditions, e.g., 'SI_SH_check'.\"\"\"\n\n    def __init__(self, name: str, groups: List[Group]) -&gt; None:\n        \"\"\"Holds multiple groups of the same experiment.\"\"\"\n        self.name = name\n        self.groups = sorted(groups, key=lambda g: g.group_type)\n        self._id2group = {g.group_type: g for g in self.groups}\n        self.num_groups = len(self.groups)\n        self.num_rois = len([roi for roi in self.iter_rois()])\n        self.title = f\"{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})\"\n\n    def __getitem__(self, group_type: str) -&gt; Group:\n        return self._id2group[group_type]\n\n    def __len__(self) -&gt; int:\n        return len(self.groups)\n\n    def __iter__(self) -&gt; Iterator[Group]:\n        return iter(self.groups)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def visualize(self) -&gt; None:\n        colors = get_n_colors_from_palette(self.num_groups)\n\n        all_traces = []\n        max_trace_val = 0\n        for color, group in zip(colors, self.groups):\n            rois_traces = [roi.trace for cs in group for roi in cs]\n            average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n            average_trace.name = f\"{group.group_type} mean\"\n            if average_trace.max() &gt; max_trace_val:\n                max_trace_val = average_trace.max()\n            group_fig = create_traces_figure(\n                main_trace=average_trace,\n                traces_color=color\n            )\n            all_traces.append(group_fig.data[0])\n\n        # Combine all traces into one figure\n        fig = go.Figure(data=all_traces)\n        fig.update_layout(\n            title=self.name,\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            xaxis=dict(showgrid=False),\n            yaxis=dict(showgrid=False),\n            template=\"plotly_white\",\n            legend=dict(\n                orientation=\"v\",\n                yanchor=\"top\",\n                y=1,\n                xanchor=\"left\",\n                x=1.05,\n                font=dict(size=10),\n                traceorder=\"normal\",\n            ),\n        )\n        fig.show()\n\n    def align_onsets(self) -&gt; None:\n        print(\"aligning onsets within each group\")\n        target_onsets = [group.align_onsets() for group in self.groups]\n        target_onset_idx = int(np.median(target_onsets))\n\n        print(f\"aligning onsets across groups to {target_onset_idx}\")\n        for group in self.groups:\n            group.align_onsets(target_onset_idx)\n\n    def get_mean_traces_df(self) -&gt; pd.DataFrame:\n        mean_traces = [group.get_mean_trace() for group in self.groups]\n        df = pd.concat(mean_traces, axis=1)\n        return df\n\n    def visualize_all_rois(self) -&gt; None:\n        for roi in self.iter_rois():\n            try:\n                roi.visualize()\n            except Exception as e:\n                print(e)\n                print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n\n    def run_manual_analysis(self) -&gt; None:\n        for i, roi in enumerate(self.iter_rois()):\n            try:\n                print(f\"ROI {i}/{self.num_rois}\")\n                self._ask_to_update_params(roi)\n            except Exception as e:\n                print(e)\n                print(\"fallback visualization: \")\n                roi.trace.plot()\n                plt.title(roi.title)\n                plt.show()\n                drop = get_bool_input(\"drop ROI? (y/n): \")\n                if drop:\n                    msg = f\"deleted {roi.title}\"\n                    del roi\n                    print(msg)\n                else:\n                    self._ask_to_update_params(roi)\n\n    @staticmethod\n    def _ask_to_update_params(roi: ROI):\n        while True:\n            roi.visualize()\n            peak_idx = get_int_input(f\"peak_idx={roi.peak_idx}, enter to accept or input to edit: \")\n            if peak_idx is not None:\n                roi.set_peak_idx(peak_idx)\n\n            onset_idx = get_int_input(f\"onset_idx={roi.onset_idx}, enter to accept or input to edit: \")\n            if onset_idx is not None:\n                roi.set_onset_idx(onset_idx)\n\n            if peak_idx is not None or onset_idx is not None:\n                roi.visualize()\n            else:\n                break\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for group in self.groups\n            for eflux_rate in group.calculate_eflux_rates()\n        ]\n\n    def _get_eflux_rates_df(self) -&gt; pd.DataFrame:\n        records = self.calculate_eflux_rates()\n        df = pd.DataFrame.from_records(records)\n        cols = df.columns.tolist()\n        df[\"experiment_name\"] = self.name\n        new_cols_order = [\"experiment_name\"] + cols\n        df = df[new_cols_order]\n        df = df.sort_values(by=[\"coverslip\", \"roi\"], ascending=True)\n        return df\n\n    def visualize_eflux_bar_chart(self) -&gt; None:\n        df = self._get_eflux_rates_df()\n        group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n        # Compute SEM and 95% CI (approx)\n        group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n        group_stats['ci95'] = 1.96 * group_stats['sem']\n\n        # Plot with 95% CI as error bars\n        fig = go.Figure([\n            go.Bar(\n                x=group_stats.index,\n                y=group_stats['mean'],\n                error_y=dict(type='data', array=group_stats['ci95']),\n                name='Mean \u00b1 95% CI'\n            )\n        ])\n        fig.update_layout(\n            title=\"Eflux mean with 95% Confidence Interval\",\n            xaxis_title=\"Group Type\",\n            yaxis_title=\"Eflux\",\n            template=\"plotly_white\"\n        )\n        fig.show()\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for group in self.groups\n            for amplitude in group.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for group in self.groups\n            for integral in group.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for group in self.groups\n            for tau in group.calculate_taus()\n        ]\n\n    def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n        return {g.group_type: g.get_df() for g in self.groups}\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n        for group_type, df in self.get_group_type_to_df().items():\n            base = results_output_dir_path / group_type\n            df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n            df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n\n    def iter_rois(self) -&gt; Iterator[ROI]:\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    yield roi\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        records = []\n        for group in self.groups:\n            for coverslip in group.coverslips:\n                for roi in coverslip.rois:\n                    try:\n                        eflux = roi.calculate_eflux()\n                    except RuntimeError:\n                        eflux = np.nan\n\n                    try:\n                        influx = roi.calculate_influx()\n                    except RuntimeError:\n                        influx = np.nan\n\n                    try:\n                        amplitude = roi.calculate_amplitude()\n                    except RuntimeError:\n                        amplitude = np.nan\n\n                    try:\n                        integral = roi.calculate_integral()\n                    except RuntimeError:\n                        integral = np.nan\n\n                    try:\n                        tau = roi.calculate_tau()\n                    except RuntimeError:\n                        tau = np.nan\n\n                    records.append({\n                        \"experiment_name\": self.name,\n                        \"group_type\": group.group_type,\n                        \"coverslip\": coverslip.id,\n                        \"roi\": roi.roi_id,\n                        \"onset_frame\": roi.onset_idx,\n                        \"peak_frame\": roi.peak_idx,\n                        \"eflux\": eflux,\n                        \"influx\": influx,\n                        \"amplitude\": amplitude,\n                        \"integral\": integral,\n                        \"tau\": tau,\n                    })\n\n        df = pd.DataFrame.from_records(records)\n        df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.groups","title":"<code>groups = sorted(groups, key=lambda g: g.group_type)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.num_groups","title":"<code>num_groups = len(self.groups)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.num_rois","title":"<code>num_rois = len([roi for roi in self.iter_rois()])</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.title","title":"<code>title = f'{name} (Groups {', '.join([str(group.group_type) for group in self.groups])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.align_onsets","title":"<code>align_onsets() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def align_onsets(self) -&gt; None:\n    print(\"aligning onsets within each group\")\n    target_onsets = [group.align_onsets() for group in self.groups]\n    target_onset_idx = int(np.median(target_onsets))\n\n    print(f\"aligning onsets across groups to {target_onset_idx}\")\n    for group in self.groups:\n        group.align_onsets(target_onset_idx)\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for group in self.groups\n        for amplitude in group.calculate_amplitudes()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for group in self.groups\n        for eflux_rate in group.calculate_eflux_rates()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for group in self.groups\n        for integral in group.calculate_integrals()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for group in self.groups\n        for tau in group.calculate_taus()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.get_full_analysis_df","title":"<code>get_full_analysis_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    records = []\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                try:\n                    eflux = roi.calculate_eflux()\n                except RuntimeError:\n                    eflux = np.nan\n\n                try:\n                    influx = roi.calculate_influx()\n                except RuntimeError:\n                    influx = np.nan\n\n                try:\n                    amplitude = roi.calculate_amplitude()\n                except RuntimeError:\n                    amplitude = np.nan\n\n                try:\n                    integral = roi.calculate_integral()\n                except RuntimeError:\n                    integral = np.nan\n\n                try:\n                    tau = roi.calculate_tau()\n                except RuntimeError:\n                    tau = np.nan\n\n                records.append({\n                    \"experiment_name\": self.name,\n                    \"group_type\": group.group_type,\n                    \"coverslip\": coverslip.id,\n                    \"roi\": roi.roi_id,\n                    \"onset_frame\": roi.onset_idx,\n                    \"peak_frame\": roi.peak_idx,\n                    \"eflux\": eflux,\n                    \"influx\": influx,\n                    \"amplitude\": amplitude,\n                    \"integral\": integral,\n                    \"tau\": tau,\n                })\n\n    df = pd.DataFrame.from_records(records)\n    df = df.sort_values(by=[\"experiment_name\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.get_group_type_to_df","title":"<code>get_group_type_to_df() -&gt; Dict[str, pd.DataFrame]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_group_type_to_df(self) -&gt; Dict[str, pd.DataFrame]:\n    return {g.group_type: g.get_df() for g in self.groups}\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.get_mean_traces_df","title":"<code>get_mean_traces_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def get_mean_traces_df(self) -&gt; pd.DataFrame:\n    mean_traces = [group.get_mean_trace() for group in self.groups]\n    df = pd.concat(mean_traces, axis=1)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.iter_rois","title":"<code>iter_rois() -&gt; Iterator[ROI]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def iter_rois(self) -&gt; Iterator[ROI]:\n    for group in self.groups:\n        for coverslip in group.coverslips:\n            for roi in coverslip.rois:\n                yield roi\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.run_manual_analysis","title":"<code>run_manual_analysis() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def run_manual_analysis(self) -&gt; None:\n    for i, roi in enumerate(self.iter_rois()):\n        try:\n            print(f\"ROI {i}/{self.num_rois}\")\n            self._ask_to_update_params(roi)\n        except Exception as e:\n            print(e)\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n            drop = get_bool_input(\"drop ROI? (y/n): \")\n            if drop:\n                msg = f\"deleted {roi.title}\"\n                del roi\n                print(msg)\n            else:\n                self._ask_to_update_params(roi)\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.save_mega_dfs","title":"<code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:  # todo handle i/o better\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n    for group_type, df in self.get_group_type_to_df().items():\n        base = results_output_dir_path / group_type\n        df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved {self.num_groups} mega dfs to {results_output_dir_path.resolve()}\")\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.visualize","title":"<code>visualize() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize(self) -&gt; None:\n    colors = get_n_colors_from_palette(self.num_groups)\n\n    all_traces = []\n    max_trace_val = 0\n    for color, group in zip(colors, self.groups):\n        rois_traces = [roi.trace for cs in group for roi in cs]\n        average_trace = pd.Series(pd.concat(rois_traces, axis=1).mean(axis=1))\n        average_trace.name = f\"{group.group_type} mean\"\n        if average_trace.max() &gt; max_trace_val:\n            max_trace_val = average_trace.max()\n        group_fig = create_traces_figure(\n            main_trace=average_trace,\n            traces_color=color\n        )\n        all_traces.append(group_fig.data[0])\n\n    # Combine all traces into one figure\n    fig = go.Figure(data=all_traces)\n    fig.update_layout(\n        title=self.name,\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        template=\"plotly_white\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n    fig.show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.visualize_all_rois","title":"<code>visualize_all_rois() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_all_rois(self) -&gt; None:\n    for roi in self.iter_rois():\n        try:\n            roi.visualize()\n        except Exception as e:\n            print(e)\n            print(f\"consider exp['{roi.group_type}'][{roi.coverslip_id}].drop(roi_id={roi.roi_id})\")\n            print(\"fallback visualization: \")\n            roi.trace.plot()\n            plt.title(roi.title)\n            plt.show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment.Experiment.visualize_eflux_bar_chart","title":"<code>visualize_eflux_bar_chart() -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\experiment.py</code> <pre><code>def visualize_eflux_bar_chart(self) -&gt; None:\n    df = self._get_eflux_rates_df()\n    group_stats = df.groupby('group_type')['eflux'].agg(['mean', 'std', 'count'])\n\n    # Compute SEM and 95% CI (approx)\n    group_stats['sem'] = group_stats['std'] / group_stats['count'] ** 0.5\n    group_stats['ci95'] = 1.96 * group_stats['sem']\n\n    # Plot with 95% CI as error bars\n    fig = go.Figure([\n        go.Bar(\n            x=group_stats.index,\n            y=group_stats['mean'],\n            error_y=dict(type='data', array=group_stats['ci95']),\n            name='Mean \u00b1 95% CI'\n        )\n    ])\n    fig.update_layout(\n        title=\"Eflux mean with 95% Confidence Interval\",\n        xaxis_title=\"Group Type\",\n        yaxis_title=\"Eflux\",\n        template=\"plotly_white\"\n    )\n    fig.show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/experiment/#calcium_imaging.data_models.experiment-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/data_models/group/","title":"calcium_imaging.data_models.group","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group","title":"<code>calcium_imaging.data_models.group</code>","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group","title":"<code>Group</code>","text":"<p>One group with certain intervention, e.g. 'shNCLX'.</p> Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>class Group:\n    \"\"\"One group with certain intervention, e.g. 'shNCLX'.\"\"\"\n\n    def __init__(self, coverslips: List[Coverslip]) -&gt; None:\n        \"\"\"Holds multiple runs of the same group\"\"\"\n        self.coverslips = self._init_coverslips(coverslips)\n        self._id2coverslip = {cs.id: cs for cs in self.coverslips}\n        self.group_type = self._infer_group_type()\n        self.title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n\n    def get_df(self) -&gt; pd.DataFrame:\n        return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def __getitem__(self, coverslip_id: int) -&gt; Coverslip:\n        return self._id2coverslip[coverslip_id]\n\n    def __len__(self) -&gt; int:\n        return len(self.coverslips)\n\n    def __iter__(self) -&gt; Iterator[Coverslip]:\n        return iter(self.coverslips)\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n        rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n        rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n        mean_trace = self.get_mean_trace()\n        base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n        create_traces_figure(\n            main_trace=mean_trace,\n            additional_traces=rois_traces,\n            additional_traces_peak_indexes=rois_peak_indexes,\n            additional_traces_onset_indexes=rois_onset_indexes,\n            additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n            title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n        ).show()\n\n    def get_mean_trace(self) -&gt; pd.Series:\n        mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n        mean_trace.name = f\"{self.group_type} mean\"\n        return mean_trace\n\n    def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n        return [\n            eflux_rate\n            for cs in self.coverslips\n            for eflux_rate in cs.calculate_eflux_rates()\n        ]\n\n    def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n        return [\n            amplitude\n            for cs in self.coverslips\n            for amplitude in cs.calculate_amplitudes()\n        ]\n\n    def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n        return [\n            integral\n            for cs in self.coverslips\n            for integral in cs.calculate_integrals()\n        ]\n\n    def calculate_taus(self) -&gt; List[Dict[str, float]]:\n        return [\n            tau\n            for cs in self.coverslips\n            for tau in cs.calculate_taus()\n        ]\n\n    def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n        if target_onset_idx is None:\n            onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n            target_onset_idx = int(np.median(onset_indexes))\n            print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n        for coverslip in self.coverslips:\n            for roi in coverslip.rois:\n                roi.shift_trace(target_onset_idx - roi.onset_idx)\n        return target_onset_idx\n\n    @staticmethod\n    def _init_coverslips(coverslips: List[Coverslip]) -&gt; List[Coverslip]:\n        coverslips = sorted(coverslips, key=lambda cs: cs.id)\n        if len(coverslips) == 0:\n            raise ValueError(f\"Initializing class Group with empty Coverslips list is illegal.\")\n        if not all([cs.group_type == coverslips[0].group_type for cs in coverslips]):\n            raise ValueError(f\"All Coverslips must share the same group type.\")\n        return coverslips\n\n    def _infer_group_type(self) -&gt; str:\n        return self.coverslips[0].group_type\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.coverslips","title":"<code>coverslips = self._init_coverslips(coverslips)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.group_type","title":"<code>group_type = self._infer_group_type()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.title","title":"<code>title = f'{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.align_onsets","title":"<code>align_onsets(target_onset_idx: Optional[int] = None) -&gt; int</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def align_onsets(self, target_onset_idx: Optional[int] = None) -&gt; int:\n    if target_onset_idx is None:\n        onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n        target_onset_idx = int(np.median(onset_indexes))\n        print(f\"aligning {len(onset_indexes)} ROIs to {target_onset_idx}\")\n    for coverslip in self.coverslips:\n        for roi in coverslip.rois:\n            roi.shift_trace(target_onset_idx - roi.onset_idx)\n    return target_onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.calculate_amplitudes","title":"<code>calculate_amplitudes() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_amplitudes(self) -&gt; List[Dict[str, float]]:\n    return [\n        amplitude\n        for cs in self.coverslips\n        for amplitude in cs.calculate_amplitudes()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.calculate_eflux_rates","title":"<code>calculate_eflux_rates() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_eflux_rates(self) -&gt; List[Dict[str, float]]:\n    return [\n        eflux_rate\n        for cs in self.coverslips\n        for eflux_rate in cs.calculate_eflux_rates()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.calculate_integrals","title":"<code>calculate_integrals() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_integrals(self) -&gt; List[Dict[str, float]]:\n    return [\n        integral\n        for cs in self.coverslips\n        for integral in cs.calculate_integrals()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.calculate_taus","title":"<code>calculate_taus() -&gt; List[Dict[str, float]]</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def calculate_taus(self) -&gt; List[Dict[str, float]]:\n    return [\n        tau\n        for cs in self.coverslips\n        for tau in cs.calculate_taus()\n    ]\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.get_df","title":"<code>get_df() -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_df(self) -&gt; pd.DataFrame:\n    return pd.concat([cs.get_df() for cs in self.coverslips], axis=1)\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.get_mean_trace","title":"<code>get_mean_trace() -&gt; pd.Series</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def get_mean_trace(self) -&gt; pd.Series:\n    mean_trace = pd.Series(pd.concat([roi.trace for cs in self.coverslips for roi in cs], axis=1).mean(axis=1))\n    mean_trace.name = f\"{self.group_type} mean\"\n    return mean_trace\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group.Group.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"Source code in <code>src\\calcium_imaging\\data_models\\group.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    rois_traces = [roi.trace for cs in self.coverslips for roi in cs]\n    rois_peak_indexes = [roi.peak_idx for cs in self.coverslips for roi in cs]\n    rois_onset_indexes = [roi.onset_idx for cs in self.coverslips for roi in cs]\n    rois_baseline_return_indexes = [roi.baseline_return_idx for cs in self.coverslips for roi in cs]\n    mean_trace = self.get_mean_trace()\n    base_title = f\"{self.group_type} (Coverslips {', '.join([str(cs.id) for cs in self.coverslips])})\"\n    create_traces_figure(\n        main_trace=mean_trace,\n        additional_traces=rois_traces,\n        additional_traces_peak_indexes=rois_peak_indexes,\n        additional_traces_onset_indexes=rois_onset_indexes,\n        additional_traces_baseline_return_indexes=rois_baseline_return_indexes,\n        title=base_title if title_prefix is None else f\"{title_prefix}\\n{base_title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/group/#calcium_imaging.data_models.group-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/research/","title":"calcium_imaging.data_models.research","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research","title":"<code>calcium_imaging.data_models.research</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research","title":"<code>Research</code>","text":"<p>A collection of multiple experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>class Research:\n    \"\"\"A collection of multiple experiments.\"\"\"\n\n    def __init__(self, name: str, experiments: List[Experiment]) -&gt; None:\n        \"\"\"Holds multiple experiments of the same research project.\"\"\"\n        self.name = name\n        self.experiments = sorted(experiments, key=lambda e: e.name)\n        self._id2experiment = {e.name: e for e in self.experiments}\n        self.num_experiments = len(self.experiments)\n        self.num_groups = sum(e.num_groups for e in self.experiments)\n        self.num_rois = sum(e.num_rois for e in self.experiments)\n        self.title = f\"{name} (Experiments {', '.join([e.name for e in self.experiments])})\"\n\n    def __getitem__(self, experiment_name: str) -&gt; Experiment:\n        return self._id2experiment[experiment_name]\n\n    def __len__(self) -&gt; int:\n        return len(self.experiments)\n\n    def __iter__(self) -&gt; Iterator[Experiment]:\n        return iter(self.experiments)\n\n    def __repr__(self) -&gt; str:\n        return self.title\n\n    def get_full_analysis_df(self) -&gt; pd.DataFrame:\n        \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n        dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n        df = pd.concat(dfs, axis=0)\n        df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n        df = df.reset_index(drop=True)\n        return df\n\n    def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n        \"\"\"Save analysis results for all experiments.\"\"\"\n        results_output_dir_path = Path(results_output_dir_path) / self.name\n        results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Save individual experiment results\n        for experiment in self.experiments:\n            experiment.save_mega_dfs(results_output_dir_path)\n\n        # Save combined results\n        combined_df = self.get_full_analysis_df()\n        base = results_output_dir_path / \"combined_analysis\"\n        combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n        combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n        print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.experiments","title":"<code>experiments = sorted(experiments, key=lambda e: e.name)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.num_experiments","title":"<code>num_experiments = len(self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.num_groups","title":"<code>num_groups = sum(e.num_groups for e in self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.num_rois","title":"<code>num_rois = sum(e.num_rois for e in self.experiments)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.title","title":"<code>title = f'{name} (Experiments {', '.join([e.name for e in self.experiments])})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.get_full_analysis_df","title":"<code>get_full_analysis_df() -&gt; pd.DataFrame</code>","text":"<p>Get a combined DataFrame of all experiments' analysis results.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def get_full_analysis_df(self) -&gt; pd.DataFrame:\n    \"\"\"Get a combined DataFrame of all experiments' analysis results.\"\"\"\n    dfs = [experiment.get_full_analysis_df() for experiment in self.experiments]\n    df = pd.concat(dfs, axis=0)\n    df = df.sort_values(by=[\"experiment_name\", \"group_type\", \"coverslip\", \"roi\"], ascending=True)\n    df = df.reset_index(drop=True)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/research/#calcium_imaging.data_models.research.Research.save_mega_dfs","title":"<code>save_mega_dfs(results_output_dir_path: str = './results') -&gt; None</code>","text":"<p>Save analysis results for all experiments.</p> Source code in <code>src\\calcium_imaging\\data_models\\research.py</code> <pre><code>def save_mega_dfs(self, results_output_dir_path: str = \"./results\") -&gt; None:\n    \"\"\"Save analysis results for all experiments.\"\"\"\n    results_output_dir_path = Path(results_output_dir_path) / self.name\n    results_output_dir_path.mkdir(parents=True, exist_ok=True)\n\n    # Save individual experiment results\n    for experiment in self.experiments:\n        experiment.save_mega_dfs(results_output_dir_path)\n\n    # Save combined results\n    combined_df = self.get_full_analysis_df()\n    base = results_output_dir_path / \"combined_analysis\"\n    combined_df.to_excel(base.with_suffix(\".xlsx\"), index=False)\n    combined_df.to_csv(base.with_suffix(\".csv\"), index=False)\n    print(f\"Successfully saved combined analysis to {results_output_dir_path.resolve()}\") \n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/","title":"calcium_imaging.data_models.roi","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi","title":"<code>calcium_imaging.data_models.roi</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI","title":"<code>ROI</code>","text":"<p>A class representing a single region of interest (ROI) in calcium imaging data.</p> <p>This class handles the analysis and visualization of calcium imaging data for a single ROI, including calculation of influx/eflux rates, amplitude, integral, and tau values.</p> <p>Attributes:</p> Name Type Description <code>coverslip_id</code> <code>int</code> <p>The ID of the coverslip this ROI belongs to.</p> <code>roi_id</code> <code>int</code> <p>The unique identifier for this ROI.</p> <code>group_type</code> <code>str</code> <p>The type of group this ROI belongs to.</p> <code>name</code> <code>str</code> <p>A formatted name combining coverslip and ROI IDs.</p> <code>title</code> <code>str</code> <p>A descriptive title for the ROI.</p> <code>time</code> <code>Series</code> <p>Time series data for the ROI.</p> <code>trace</code> <code>Series</code> <p>Fluorescence trace data for the ROI.</p> <code>onset_idx</code> <code>int</code> <p>Index of the onset of the calcium response.</p> <code>peak_idx</code> <code>int</code> <p>Index of the peak of the calcium response.</p> <code>influx_start_idx</code> <code>int</code> <p>Start index for influx calculation.</p> <code>influx_end_idx</code> <code>int</code> <p>End index for influx calculation.</p> <code>eflux_start_idx</code> <code>int</code> <p>Start index for eflux calculation.</p> <code>eflux_end_idx</code> <code>int</code> <p>End index for eflux calculation.</p> <code>baseline_return_idx</code> <code>int</code> <p>Index where the trace returns to baseline.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>class ROI:\n    \"\"\"A class representing a single region of interest (ROI) in calcium imaging data.\n\n    This class handles the analysis and visualization of calcium imaging data for a single ROI,\n    including calculation of influx/eflux rates, amplitude, integral, and tau values.\n\n    Attributes:\n        coverslip_id (int): The ID of the coverslip this ROI belongs to.\n        roi_id (int): The unique identifier for this ROI.\n        group_type (str): The type of group this ROI belongs to.\n        name (str): A formatted name combining coverslip and ROI IDs.\n        title (str): A descriptive title for the ROI.\n        time (pd.Series): Time series data for the ROI.\n        trace (pd.Series): Fluorescence trace data for the ROI.\n        onset_idx (int): Index of the onset of the calcium response.\n        peak_idx (int): Index of the peak of the calcium response.\n        influx_start_idx (int): Start index for influx calculation.\n        influx_end_idx (int): End index for influx calculation.\n        eflux_start_idx (int): Start index for eflux calculation.\n        eflux_end_idx (int): End index for eflux calculation.\n        baseline_return_idx (int): Index where the trace returns to baseline.\n    \"\"\"\n    EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5\n\n    def __init__(\n            self,\n            trace: pd.Series,\n            time: pd.Series,\n            roi_id: int,\n            coverslip_id: int,\n            group_type: str,\n    ) -&gt; None:\n        \"\"\"Initialize a new ROI instance.\n\n        Args:\n            trace (pd.Series): The fluorescence trace data for this ROI.\n            time (pd.Series): The time series data corresponding to the trace.\n            roi_id (int): The unique identifier for this ROI.\n            coverslip_id (int): The ID of the coverslip this ROI belongs to.\n            group_type (str): The type of group this ROI belongs to.\n        \"\"\"\n        self.coverslip_id = coverslip_id\n        self.roi_id = roi_id\n        self.group_type = group_type\n        self.name = f\"cs-{self.coverslip_id}_roi-{self.roi_id}\"\n        self.title = f\"ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})\"\n        self.time = time.copy(deep=True).rename(f\"time_{self.name}\")\n        self.trace = trace.copy(deep=True).rename(self.name)\n        self.onset_idx = detect_onset_index(self.trace)\n        self.peak_idx = detect_peak_index(self.trace)\n        self.influx_start_idx = self.onset_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.eflux_end_idx = detect_eflux_end_index(self.trace)\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def shift_trace(self, periods: int) -&gt; None:\n        \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n        Args:\n            periods (int): Number of periods to shift the trace and indices.\n        \"\"\"\n        self.time = self.time.shift(periods)\n        self.trace = self.trace.shift(periods)\n        self.onset_idx = self.onset_idx + periods\n        self.peak_idx = self.peak_idx + periods\n        self.influx_start_idx = self.influx_start_idx + periods\n        self.influx_end_idx = self.influx_end_idx + periods\n        self.eflux_start_idx = self.eflux_start_idx + periods\n        self.eflux_end_idx = self.eflux_end_idx + periods\n        self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n\n    def calculate_influx(self) -&gt; float:\n        \"\"\"Calculate the influx rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated influx rate.\n        \"\"\"\n        return calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        ).slope\n\n    def calculate_eflux(self) -&gt; float:\n        \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n        Returns:\n            float: The calculated eflux rate.\n        \"\"\"\n        return calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        ).slope\n\n    def calculate_amplitude(self) -&gt; float:\n        \"\"\"Calculate the amplitude of the calcium response.\n\n        Returns:\n            float: The amplitude, calculated as the peak value minus 1.\n        \"\"\"\n        return self.trace[self.peak_idx] - 1\n\n    def calculate_integral(self) -&gt; float:\n        \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n        Returns:\n            float: The calculated integral of the trace.\n\n        Raises:\n            ValueError: If baseline_return_idx is not set (equals -999).\n        \"\"\"\n        # Get the relevant portions of the trace and time series\n        trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n        time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n        # Calculate integral using trapezoidal rule\n        integral = np.trapz(trace_segment, time_segment)\n        return integral\n\n    def calculate_tau(self) -&gt; float:\n        \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n        Tau is calculated as the time between the peak and when the trace reaches\n        63.2% of the amplitude decay from peak.\n\n        Returns:\n            float: The calculated tau value.\n        \"\"\"\n        peak_value = self.trace[self.peak_idx]\n        target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n        # Search forward from peak to find where trace crosses target value\n        for idx in range(self.peak_idx, len(self.trace)):\n            if self.trace.loc[idx] &lt;= target_value:\n                return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n        return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n\n    def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n        \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n        Args:\n            title_prefix (Optional[str]): Optional prefix to add to the plot title.\n        \"\"\"\n        influx_linear_coefficients = calculate_influx_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.influx_start_idx,\n            end_idx=self.influx_end_idx\n        )\n        eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n            trace=self.trace,\n            start_idx=self.eflux_start_idx,\n            end_idx=self.eflux_end_idx\n        )\n        create_traces_figure(\n            main_trace=self.trace,\n            title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n            xaxis_title=\"Frame\",\n            yaxis_title=\"Fluorescence relative to background\",\n            main_trace_peak_index=self.peak_idx,\n            main_trace_onset_index=self.onset_idx,\n            main_trace_baseline_return_index=self.baseline_return_idx,\n            eflux_linear_coefficients=eflux_linear_coefficients,\n            influx_linear_coefficients=influx_linear_coefficients\n        ).show()\n\n    def set_peak_idx(self, peak_idx: int) -&gt; None:\n        \"\"\"Set a new peak index and update related indices.\n\n        Args:\n            peak_idx (int): The new peak index to set.\n        \"\"\"\n        self.peak_idx = peak_idx\n        self.influx_end_idx = self.peak_idx\n        self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n        self.baseline_return_idx = detect_baseline_return_idx(\n            self.trace, self.eflux_start_idx\n        )\n\n    def set_onset_idx(self, onset_idx: int) -&gt; None:\n        \"\"\"Set a new onset index and update related indices.\n\n        Args:\n            onset_idx (int): The new onset index to set.\n        \"\"\"\n        self.onset_idx = onset_idx\n        self.influx_start_idx = self.onset_idx\n\n    def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n        \"\"\"Set a new baseline return index.\n\n        Args:\n            baseline_return_idx (int): The new baseline return index to set.\n        \"\"\"\n        self.baseline_return_idx = baseline_return_idx\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the ROI.\n\n        Returns:\n            str: A string containing the ROI's title.\n        \"\"\"\n        return self.title\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.EFLUX_START_INDEX_OFFSET_FROM_PEAK","title":"<code>EFLUX_START_INDEX_OFFSET_FROM_PEAK = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.baseline_return_idx","title":"<code>baseline_return_idx = detect_baseline_return_idx(self.trace, self.eflux_start_idx)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.coverslip_id","title":"<code>coverslip_id = coverslip_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.eflux_end_idx","title":"<code>eflux_end_idx = detect_eflux_end_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.eflux_start_idx","title":"<code>eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.group_type","title":"<code>group_type = group_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.influx_end_idx","title":"<code>influx_end_idx = self.peak_idx</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.influx_start_idx","title":"<code>influx_start_idx = self.onset_idx</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.name","title":"<code>name = f'cs-{self.coverslip_id}_roi-{self.roi_id}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.onset_idx","title":"<code>onset_idx = detect_onset_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.peak_idx","title":"<code>peak_idx = detect_peak_index(self.trace)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.roi_id","title":"<code>roi_id = roi_id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.time","title":"<code>time = time.copy(deep=True).rename(f'time_{self.name}')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.title","title":"<code>title = f'ROI {self.roi_id} (Coverslip {self.coverslip_id}, {self.group_type})'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.trace","title":"<code>trace = trace.copy(deep=True).rename(self.name)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.calculate_amplitude","title":"<code>calculate_amplitude() -&gt; float</code>","text":"<p>Calculate the amplitude of the calcium response.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The amplitude, calculated as the peak value minus 1.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_amplitude(self) -&gt; float:\n    \"\"\"Calculate the amplitude of the calcium response.\n\n    Returns:\n        float: The amplitude, calculated as the peak value minus 1.\n    \"\"\"\n    return self.trace[self.peak_idx] - 1\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.calculate_eflux","title":"<code>calculate_eflux() -&gt; float</code>","text":"<p>Calculate the eflux rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated eflux rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_eflux(self) -&gt; float:\n    \"\"\"Calculate the eflux rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated eflux rate.\n    \"\"\"\n    return calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    ).slope\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.calculate_influx","title":"<code>calculate_influx() -&gt; float</code>","text":"<p>Calculate the influx rate of calcium for this ROI.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated influx rate.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_influx(self) -&gt; float:\n    \"\"\"Calculate the influx rate of calcium for this ROI.\n\n    Returns:\n        float: The calculated influx rate.\n    \"\"\"\n    return calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    ).slope\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.calculate_integral","title":"<code>calculate_integral() -&gt; float</code>","text":"<p>Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated integral of the trace.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If baseline_return_idx is not set (equals -999).</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_integral(self) -&gt; float:\n    \"\"\"Calculate the integral of the trace from onset to baseline return using the trapezoidal rule.\n\n    Returns:\n        float: The calculated integral of the trace.\n\n    Raises:\n        ValueError: If baseline_return_idx is not set (equals -999).\n    \"\"\"\n    # Get the relevant portions of the trace and time series\n    trace_segment = self.trace.loc[self.onset_idx:self.baseline_return_idx + 1]\n    time_segment = self.time.loc[self.onset_idx:self.baseline_return_idx + 1]\n\n    # Calculate integral using trapezoidal rule\n    integral = np.trapz(trace_segment, time_segment)\n    return integral\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.calculate_tau","title":"<code>calculate_tau() -&gt; float</code>","text":"<p>Calculate the time constant (tau) of the calcium response decay.</p> <p>Tau is calculated as the time between the peak and when the trace reaches 63.2% of the amplitude decay from peak.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated tau value.</p> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def calculate_tau(self) -&gt; float:\n    \"\"\"Calculate the time constant (tau) of the calcium response decay.\n\n    Tau is calculated as the time between the peak and when the trace reaches\n    63.2% of the amplitude decay from peak.\n\n    Returns:\n        float: The calculated tau value.\n    \"\"\"\n    peak_value = self.trace[self.peak_idx]\n    target_value = 1 + (peak_value - 1) * 0.368  # 63.2% decay from peak\n\n    # Search forward from peak to find where trace crosses target value\n    for idx in range(self.peak_idx, len(self.trace)):\n        if self.trace.loc[idx] &lt;= target_value:\n            return self.time.loc[idx] - self.time.loc[self.peak_idx]\n\n    return self.time.loc[self.baseline_return_idx] - self.time.loc[self.peak_idx]  # Return time between peak and baseline return\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.set_baseline_return_idx","title":"<code>set_baseline_return_idx(baseline_return_idx: int) -&gt; None</code>","text":"<p>Set a new baseline return index.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_return_idx</code> <code>int</code> <p>The new baseline return index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_baseline_return_idx(self, baseline_return_idx: int) -&gt; None:\n    \"\"\"Set a new baseline return index.\n\n    Args:\n        baseline_return_idx (int): The new baseline return index to set.\n    \"\"\"\n    self.baseline_return_idx = baseline_return_idx\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.set_onset_idx","title":"<code>set_onset_idx(onset_idx: int) -&gt; None</code>","text":"<p>Set a new onset index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>onset_idx</code> <code>int</code> <p>The new onset index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_onset_idx(self, onset_idx: int) -&gt; None:\n    \"\"\"Set a new onset index and update related indices.\n\n    Args:\n        onset_idx (int): The new onset index to set.\n    \"\"\"\n    self.onset_idx = onset_idx\n    self.influx_start_idx = self.onset_idx\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.set_peak_idx","title":"<code>set_peak_idx(peak_idx: int) -&gt; None</code>","text":"<p>Set a new peak index and update related indices.</p> <p>Parameters:</p> Name Type Description Default <code>peak_idx</code> <code>int</code> <p>The new peak index to set.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def set_peak_idx(self, peak_idx: int) -&gt; None:\n    \"\"\"Set a new peak index and update related indices.\n\n    Args:\n        peak_idx (int): The new peak index to set.\n    \"\"\"\n    self.peak_idx = peak_idx\n    self.influx_end_idx = self.peak_idx\n    self.eflux_start_idx = self.peak_idx + self.EFLUX_START_INDEX_OFFSET_FROM_PEAK\n    self.baseline_return_idx = detect_baseline_return_idx(\n        self.trace, self.eflux_start_idx\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.shift_trace","title":"<code>shift_trace(periods: int) -&gt; None</code>","text":"<p>Shift the trace and all associated indices by a specified number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to shift the trace and indices.</p> required Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def shift_trace(self, periods: int) -&gt; None:\n    \"\"\"Shift the trace and all associated indices by a specified number of periods.\n\n    Args:\n        periods (int): Number of periods to shift the trace and indices.\n    \"\"\"\n    self.time = self.time.shift(periods)\n    self.trace = self.trace.shift(periods)\n    self.onset_idx = self.onset_idx + periods\n    self.peak_idx = self.peak_idx + periods\n    self.influx_start_idx = self.influx_start_idx + periods\n    self.influx_end_idx = self.influx_end_idx + periods\n    self.eflux_start_idx = self.eflux_start_idx + periods\n    self.eflux_end_idx = self.eflux_end_idx + periods\n    self.baseline_return_idx = min(self.baseline_return_idx + periods, self.trace.index[-1])\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi.ROI.visualize","title":"<code>visualize(title_prefix: Optional[str] = None) -&gt; None</code>","text":"<p>Create and display a visualization of the ROI trace with key points marked.</p> <p>Parameters:</p> Name Type Description Default <code>title_prefix</code> <code>Optional[str]</code> <p>Optional prefix to add to the plot title.</p> <code>None</code> Source code in <code>src\\calcium_imaging\\data_models\\roi.py</code> <pre><code>def visualize(self, title_prefix: Optional[str] = None) -&gt; None:\n    \"\"\"Create and display a visualization of the ROI trace with key points marked.\n\n    Args:\n        title_prefix (Optional[str]): Optional prefix to add to the plot title.\n    \"\"\"\n    influx_linear_coefficients = calculate_influx_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.influx_start_idx,\n        end_idx=self.influx_end_idx\n    )\n    eflux_linear_coefficients = calculate_eflux_linear_coefficients(\n        trace=self.trace,\n        start_idx=self.eflux_start_idx,\n        end_idx=self.eflux_end_idx\n    )\n    create_traces_figure(\n        main_trace=self.trace,\n        title=self.title if title_prefix is None else f\"{title_prefix}\\n{self.title}\",\n        xaxis_title=\"Frame\",\n        yaxis_title=\"Fluorescence relative to background\",\n        main_trace_peak_index=self.peak_idx,\n        main_trace_onset_index=self.onset_idx,\n        main_trace_baseline_return_index=self.baseline_return_idx,\n        eflux_linear_coefficients=eflux_linear_coefficients,\n        influx_linear_coefficients=influx_linear_coefficients\n    ).show()\n</code></pre>"},{"location":"reference/calcium_imaging/data_models/roi/#calcium_imaging.data_models.roi-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/io/","title":"calcium_imaging.io","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io","title":"<code>calcium_imaging.io</code>","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.load_vsi","title":"<code>load_vsi</code>","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.load_vsi-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.load_vsi.load_vsi","title":"<code>load_vsi(path: Path) -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\io\\load_vsi.py</code> <pre><code>def load_vsi(path: Path) -&gt; pd.DataFrame:\n    if path.suffix == \".xls\":\n        return _load_xls(path)\n    raise ValueError(f\"Unsupported file type '{path.suffix}' for file '{path.resolve()}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.validate_experiment_dir","title":"<code>validate_experiment_dir</code>","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.validate_experiment_dir-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/io/#calcium_imaging.io.validate_experiment_dir.validate_experiment_dir","title":"<code>validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path</code>","text":"Source code in <code>src\\calcium_imaging\\io\\validate_experiment_dir.py</code> <pre><code>def validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path:\n    if isinstance(experiment_dir, str):\n        experiment_dir_path = Path(experiment_dir)\n    elif isinstance(experiment_dir, Path):\n        experiment_dir_path = experiment_dir\n    else:\n        raise ValueError(f\"Illegal type {type(experiment_dir)} for experiment_dir. \"\n                         f\"Provide either str or Path.\")\n    if not experiment_dir_path.exists():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' doesn't exist.\")\n    if not experiment_dir_path.is_dir():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' is not a directory.\")\n    return experiment_dir_path\n</code></pre>"},{"location":"reference/calcium_imaging/io/load_vsi/","title":"calcium_imaging.io.load_vsi","text":""},{"location":"reference/calcium_imaging/io/load_vsi/#calcium_imaging.io.load_vsi","title":"<code>calcium_imaging.io.load_vsi</code>","text":""},{"location":"reference/calcium_imaging/io/load_vsi/#calcium_imaging.io.load_vsi-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/io/load_vsi/#calcium_imaging.io.load_vsi.load_vsi","title":"<code>load_vsi(path: Path) -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\io\\load_vsi.py</code> <pre><code>def load_vsi(path: Path) -&gt; pd.DataFrame:\n    if path.suffix == \".xls\":\n        return _load_xls(path)\n    raise ValueError(f\"Unsupported file type '{path.suffix}' for file '{path.resolve()}'\")\n</code></pre>"},{"location":"reference/calcium_imaging/io/validate_experiment_dir/","title":"calcium_imaging.io.validate_experiment_dir","text":""},{"location":"reference/calcium_imaging/io/validate_experiment_dir/#calcium_imaging.io.validate_experiment_dir","title":"<code>calcium_imaging.io.validate_experiment_dir</code>","text":""},{"location":"reference/calcium_imaging/io/validate_experiment_dir/#calcium_imaging.io.validate_experiment_dir-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/io/validate_experiment_dir/#calcium_imaging.io.validate_experiment_dir.validate_experiment_dir","title":"<code>validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path</code>","text":"Source code in <code>src\\calcium_imaging\\io\\validate_experiment_dir.py</code> <pre><code>def validate_experiment_dir(experiment_dir: Union[str, Path]) -&gt; Path:\n    if isinstance(experiment_dir, str):\n        experiment_dir_path = Path(experiment_dir)\n    elif isinstance(experiment_dir, Path):\n        experiment_dir_path = experiment_dir\n    else:\n        raise ValueError(f\"Illegal type {type(experiment_dir)} for experiment_dir. \"\n                         f\"Provide either str or Path.\")\n    if not experiment_dir_path.exists():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' doesn't exist.\")\n    if not experiment_dir_path.is_dir():\n        raise ValueError(f\"experiment_dir '{experiment_dir}' is not a directory.\")\n    return experiment_dir_path\n</code></pre>"},{"location":"reference/calcium_imaging/processing/","title":"calcium_imaging.processing","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing","title":"<code>calcium_imaging.processing</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants","title":"<code>constants</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROIS","title":"<code>BACKGROUND_FLUORESCENCE_ROIS = [BACKGROUND_FLUORESCENCE_ROI_1, BACKGROUND_FLUORESCENCE_ROI_2, BACKGROUND_FLUORESCENCE_ROI_3]</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_1","title":"<code>BACKGROUND_FLUORESCENCE_ROI_1 = 'ROI 1 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_2","title":"<code>BACKGROUND_FLUORESCENCE_ROI_2 = 'ROI 2 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_3","title":"<code>BACKGROUND_FLUORESCENCE_ROI_3 = 'ROI 3 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.COVERSLIP_FILENAME_STEM_PATTERN","title":"<code>COVERSLIP_FILENAME_STEM_PATTERN = re.compile('^\\\\s*(?P&lt;coverslip_id&gt;\\\\d+)\\\\s*-\\\\s*(?P&lt;group_type&gt;.+?)\\\\s*$')</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.ROI_COL_PATTERN","title":"<code>ROI_COL_PATTERN = re.compile('^ROI\\\\s*(\\\\d+)\\\\s*\\\\(Average\\\\)$')</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.constants.TIME_COL","title":"<code>TIME_COL = 'Time (ms)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename","title":"<code>extract_coverslip_info_from_filename</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename.CoverslipInfo","title":"<code>CoverslipInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>class CoverslipInfo(NamedTuple):\n    coverslip_id: int\n    group_type: str\n</code></pre> Attributes\u00b6 <code>coverslip_id: int</code> <code>instance-attribute</code> \u00b6 <code>group_type: str</code> <code>instance-attribute</code> \u00b6"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem","title":"<code>extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo</code>","text":"<p>Extracts coverslip ID and group type from a string of the form ' - ' and returns a CoverslipInfo tuple."},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--parameters","title":"Parameters","text":"<p>filename : str     The filename or label to parse.</p>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--returns","title":"Returns","text":"<p>CoverslipInfo     NamedTuple(coverslip_id, group_type)</p>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--raises","title":"Raises","text":"<p>ValueError     If <code>name</code> doesn\u2019t match the expected pattern.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>def extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo:\n    \"\"\"\n    Extracts coverslip ID and group type from a string of the form\n    '&lt;coverslip_id&gt; - &lt;group_type&gt;' and returns a CoverslipInfo tuple.\n\n    Parameters\n    ----------\n    filename : str\n        The filename or label to parse.\n\n    Returns\n    -------\n    CoverslipInfo\n        NamedTuple(coverslip_id, group_type)\n\n    Raises\n    ------\n    ValueError\n        If `name` doesn\u2019t match the expected pattern.\n    \"\"\"\n    m = COVERSLIP_FILENAME_STEM_PATTERN.match(filename)\n    if not m:\n        raise ValueError(\n            f\"Invalid format {filename!r}; expected '&lt;coverslip_id&gt; - &lt;group_type&gt;'.\"\n        )\n    return CoverslipInfo(\n        coverslip_id=int(m.group('coverslip_id')),\n        group_type=m.group('group_type').strip()\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]</code>","text":"<p>Extract the ROI ID from a column name of the form 'ROI  (Average)'."},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--parameters","title":"Parameters","text":"<p>col_name : str     The column name to inspect.</p>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--returns","title":"Returns","text":"<p>Optional[int]     The integer ROI number if the name matches, otherwise None.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_roi_id_from_col_name.py</code> <pre><code>def extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]:\n    \"\"\"\n    Extract the ROI ID from a column name of the form 'ROI &lt;number&gt; (Average)'.\n\n    Parameters\n    ----------\n    col_name : str\n        The column name to inspect.\n\n    Returns\n    -------\n    Optional[int]\n        The integer ROI number if the name matches, otherwise None.\n    \"\"\"\n    m = ROI_COL_PATTERN.match(col_name)\n    return int(m.group(1)) if m else None\n</code></pre>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.preprocessor","title":"<code>preprocessor</code>","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.preprocessor-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.preprocessor-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.preprocessor.Preprocessor","title":"<code>Preprocessor</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>class Preprocessor:\n    def __init__(\n            self,\n            first_n_points_to_discard: int = 5,\n            smoothing_windows_size: int = 2,\n            time_col_name: str = TIME_COL,\n            background_fluorescence_cols_names: List[str] = BACKGROUND_FLUORESCENCE_ROIS,\n            normalization_sampling_start_frame: int = 1,\n            normalization_sampling_end_frame: int = 35,\n            earliest_onset_frame: int = 50,\n            earliest_baseline_recovery_frame: int = 90,\n            drop_traces_with_corrupted_peak: bool = False,\n            drop_background_fluorescence_cols: bool = True\n    ) -&gt; None:\n        self.first_n_points_to_discard = first_n_points_to_discard\n        self.smoothing_windows_size = smoothing_windows_size\n        self.time_col_name = time_col_name\n        self.background_fluorescence_cols_names = background_fluorescence_cols_names\n        self.normalization_sampling_start_frame = normalization_sampling_start_frame\n        self.normalization_sampling_end_frame = normalization_sampling_end_frame\n        self.earliest_onset_frame = earliest_onset_frame\n        self.earliest_baseline_recovery_frame = earliest_baseline_recovery_frame\n        self.drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak\n        self.drop_background_fluorescence_cols = drop_background_fluorescence_cols\n\n    def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        df = df.copy(deep=True)\n        df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n        df = self.smoothen(df, window_size=self.smoothing_windows_size)\n        df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n        if self.drop_background_fluorescence_cols:\n            df = df.drop(columns=self.background_fluorescence_cols_names)\n        df = self.normalize(\n            df=df,\n            sampling_start_frame=self.normalization_sampling_start_frame,\n            sampling_end_frame=self.normalization_sampling_end_frame\n        )\n        df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n        return df\n\n    @staticmethod\n    def discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n        return df.iloc[n:]\n\n    @staticmethod\n    def smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        return df.rolling(\n            window=window_size,\n            min_periods=1,  # allow smaller windows at edges\n            center=True\n        ).mean()\n\n    @staticmethod\n    def subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n        averaged = df[background_roi_cols].mean(axis=1)\n        result_df = df.subtract(averaged, axis=0)\n        return result_df\n\n    @staticmethod\n    def normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n        result_df = df.div(f0, axis=1)\n        return result_df\n\n    @staticmethod\n    def reject_noise(\n            df: pd.DataFrame,\n            *,\n            start_index: int = 35,\n            factor_mean: float = 7.0,\n            factor_peak: float = 2.0,\n            overshoot_thresh: float = 2.0,\n            overshoot_repl: float = 3.0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Drop columns considered artifactual.\n\n        Criteria (mirrors original MATLAB logic):\n\n        1. Global peak occurs before the rising point  \u2192 remove column.\n        2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n        3. Overshoot spikes above threshold are *corrected* in-place\n           before criteria 1\u20132 are evaluated.\n\n        Returns\n        -------\n        pd.DataFrame\n            Cleaned dataframe with offending columns removed.\n        \"\"\"\n        cleaned = df.copy(deep=True)\n\n        for col in cleaned.columns:\n            s = cleaned[col]\n\n            # step-wise overshoot correction (in-place)\n            cleaned[col] = Preprocessor.correct_overshoot(\n                s,\n                factor_threshold=overshoot_thresh,\n                factor_replacement=overshoot_repl,\n            )\n\n            if Preprocessor.noisy_pre_rise(\n                    cleaned[col], factor_mean, factor_peak, start_index\n            ):\n                cleaned.drop(columns=[col], inplace=True)\n\n        return cleaned\n\n    # ------------------------------------------------------------------\n    def _detect_traces_with_corrupted_peak(self, df: pd.DataFrame, drop: bool = False) -&gt; pd.DataFrame:\n        \"\"\"True if the global maximum is located *before* `start_index`.\"\"\"\n        result_df = df.copy(deep=True)\n        for col, trace in df.items():\n            idx_max = trace.index.values[trace.argmax()]\n            if idx_max &lt; self.earliest_onset_frame:\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n                print(f\"   warning {col}: peak detected before frame {self.earliest_onset_frame}, drop={drop}\")\n            if idx_max &gt; self.earliest_baseline_recovery_frame:\n                print(f\"   warning {col}: peak detected after frame {self.earliest_baseline_recovery_frame}, drop={drop}\")\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n        return result_df\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def correct_overshoot(\n            trace: pd.Series,\n            factor_threshold: float,\n            factor_replacement: float,\n            pre_window: int = 35,\n    ) -&gt; pd.Series:\n        \"\"\"\n        Clamp samples whose value exceeds\n            smooth + factor_threshold * mean_pre_peaks\n        to\n            smooth + factor_replacement * mean_pre_peaks.\n\n        The moving-average of the trace (window=10) is used as the\n        \u201csmooth\u201d estimate.\n        \"\"\"\n        if trace.isna().all():\n            return trace\n\n        smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n        # peaks only in the pre-rise region\n        peaks, _ = find_peaks(trace.iloc[:pre_window])\n        mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n        threshold = smooth + factor_threshold * mean_pre_peaks\n        replacement = smooth + factor_replacement * mean_pre_peaks\n\n        corrected = trace.where(trace &lt;= threshold, replacement)\n        return corrected\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def noisy_pre_rise(\n            trace: pd.Series,\n            factor_mean: float,\n            factor_peak: float,\n            start_index: int = 35,\n    ) -&gt; bool:\n        \"\"\"\n        Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n        Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n        Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n        \"\"\"\n        if trace.isna().all():\n            return True\n\n        pre_segment = trace.iloc[:start_index]\n        peaks, _ = find_peaks(pre_segment)\n\n        if peaks.size == 0:\n            return False  # no peaks \u21d2 not noisy by this definition\n\n        peaks_vals = pre_segment.iloc[peaks]\n        global_max = trace.max()\n\n        condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n        condition2 = peaks_vals.max() * factor_peak &gt; global_max\n        return condition1 or condition2\n</code></pre> Attributes\u00b6 <code>background_fluorescence_cols_names = background_fluorescence_cols_names</code> <code>instance-attribute</code> \u00b6 <code>drop_background_fluorescence_cols = drop_background_fluorescence_cols</code> <code>instance-attribute</code> \u00b6 <code>drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak</code> <code>instance-attribute</code> \u00b6 <code>earliest_baseline_recovery_frame = earliest_baseline_recovery_frame</code> <code>instance-attribute</code> \u00b6 <code>earliest_onset_frame = earliest_onset_frame</code> <code>instance-attribute</code> \u00b6 <code>first_n_points_to_discard = first_n_points_to_discard</code> <code>instance-attribute</code> \u00b6 <code>normalization_sampling_end_frame = normalization_sampling_end_frame</code> <code>instance-attribute</code> \u00b6 <code>normalization_sampling_start_frame = normalization_sampling_start_frame</code> <code>instance-attribute</code> \u00b6 <code>smoothing_windows_size = smoothing_windows_size</code> <code>instance-attribute</code> \u00b6 <code>time_col_name = time_col_name</code> <code>instance-attribute</code> \u00b6 Functions\u00b6 <code>correct_overshoot(trace: pd.Series, factor_threshold: float, factor_replacement: float, pre_window: int = 35) -&gt; pd.Series</code> <code>staticmethod</code> \u00b6 <p>Clamp samples whose value exceeds     smooth + factor_threshold * mean_pre_peaks to     smooth + factor_replacement * mean_pre_peaks.</p> <p>The moving-average of the trace (window=10) is used as the \u201csmooth\u201d estimate.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef correct_overshoot(\n        trace: pd.Series,\n        factor_threshold: float,\n        factor_replacement: float,\n        pre_window: int = 35,\n) -&gt; pd.Series:\n    \"\"\"\n    Clamp samples whose value exceeds\n        smooth + factor_threshold * mean_pre_peaks\n    to\n        smooth + factor_replacement * mean_pre_peaks.\n\n    The moving-average of the trace (window=10) is used as the\n    \u201csmooth\u201d estimate.\n    \"\"\"\n    if trace.isna().all():\n        return trace\n\n    smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n    # peaks only in the pre-rise region\n    peaks, _ = find_peaks(trace.iloc[:pre_window])\n    mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n    threshold = smooth + factor_threshold * mean_pre_peaks\n    replacement = smooth + factor_replacement * mean_pre_peaks\n\n    corrected = trace.where(trace &lt;= threshold, replacement)\n    return corrected\n</code></pre> <code>discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n    return df.iloc[n:]\n</code></pre> <code>noisy_pre_rise(trace: pd.Series, factor_mean: float, factor_peak: float, start_index: int = 35) -&gt; bool</code> <code>staticmethod</code> \u00b6 <p>Returns True if the pre-rise segment is noisy per MATLAB rules.</p> <p>Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef noisy_pre_rise(\n        trace: pd.Series,\n        factor_mean: float,\n        factor_peak: float,\n        start_index: int = 35,\n) -&gt; bool:\n    \"\"\"\n    Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n    Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n    Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n    \"\"\"\n    if trace.isna().all():\n        return True\n\n    pre_segment = trace.iloc[:start_index]\n    peaks, _ = find_peaks(pre_segment)\n\n    if peaks.size == 0:\n        return False  # no peaks \u21d2 not noisy by this definition\n\n    peaks_vals = pre_segment.iloc[peaks]\n    global_max = trace.max()\n\n    condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n    condition2 = peaks_vals.max() * factor_peak &gt; global_max\n    return condition1 or condition2\n</code></pre> <code>normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n    result_df = df.div(f0, axis=1)\n    return result_df\n</code></pre> <code>preprocess(df: pd.DataFrame) -&gt; pd.DataFrame</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n    df = df.copy(deep=True)\n    df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n    df = self.smoothen(df, window_size=self.smoothing_windows_size)\n    df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n    if self.drop_background_fluorescence_cols:\n        df = df.drop(columns=self.background_fluorescence_cols_names)\n    df = self.normalize(\n        df=df,\n        sampling_start_frame=self.normalization_sampling_start_frame,\n        sampling_end_frame=self.normalization_sampling_end_frame\n    )\n    df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n    return df\n</code></pre> <code>reject_noise(df: pd.DataFrame, *, start_index: int = 35, factor_mean: float = 7.0, factor_peak: float = 2.0, overshoot_thresh: float = 2.0, overshoot_repl: float = 3.0) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Drop columns considered artifactual.</p> <p>Criteria (mirrors original MATLAB logic):</p> <ol> <li>Global peak occurs before the rising point  \u2192 remove column.</li> <li>Pre-rise segment too noisy (see <code>noisy_pre_rise</code>)            \u2192 remove.</li> <li>Overshoot spikes above threshold are corrected in-place    before criteria 1\u20132 are evaluated.</li> </ol> <code>smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 <p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    return df.rolling(\n        window=window_size,\n        min_periods=1,  # allow smaller windows at edges\n        center=True\n    ).mean()\n</code></pre> <code>subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame</code> <code>staticmethod</code> \u00b6 Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n    averaged = df[background_roi_cols].mean(axis=1)\n    result_df = df.subtract(averaged, axis=0)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/processing/#calcium_imaging.processing.preprocessor.Preprocessor.reject_noise--returns","title":"Returns","text":"<p>pd.DataFrame     Cleaned dataframe with offending columns removed.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef reject_noise(\n        df: pd.DataFrame,\n        *,\n        start_index: int = 35,\n        factor_mean: float = 7.0,\n        factor_peak: float = 2.0,\n        overshoot_thresh: float = 2.0,\n        overshoot_repl: float = 3.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Drop columns considered artifactual.\n\n    Criteria (mirrors original MATLAB logic):\n\n    1. Global peak occurs before the rising point  \u2192 remove column.\n    2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n    3. Overshoot spikes above threshold are *corrected* in-place\n       before criteria 1\u20132 are evaluated.\n\n    Returns\n    -------\n    pd.DataFrame\n        Cleaned dataframe with offending columns removed.\n    \"\"\"\n    cleaned = df.copy(deep=True)\n\n    for col in cleaned.columns:\n        s = cleaned[col]\n\n        # step-wise overshoot correction (in-place)\n        cleaned[col] = Preprocessor.correct_overshoot(\n            s,\n            factor_threshold=overshoot_thresh,\n            factor_replacement=overshoot_repl,\n        )\n\n        if Preprocessor.noisy_pre_rise(\n                cleaned[col], factor_mean, factor_peak, start_index\n        ):\n            cleaned.drop(columns=[col], inplace=True)\n\n    return cleaned\n</code></pre>"},{"location":"reference/calcium_imaging/processing/constants/","title":"calcium_imaging.processing.constants","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants","title":"<code>calcium_imaging.processing.constants</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROIS","title":"<code>BACKGROUND_FLUORESCENCE_ROIS = [BACKGROUND_FLUORESCENCE_ROI_1, BACKGROUND_FLUORESCENCE_ROI_2, BACKGROUND_FLUORESCENCE_ROI_3]</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_1","title":"<code>BACKGROUND_FLUORESCENCE_ROI_1 = 'ROI 1 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_2","title":"<code>BACKGROUND_FLUORESCENCE_ROI_2 = 'ROI 2 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.BACKGROUND_FLUORESCENCE_ROI_3","title":"<code>BACKGROUND_FLUORESCENCE_ROI_3 = 'ROI 3 (Average)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.COVERSLIP_FILENAME_STEM_PATTERN","title":"<code>COVERSLIP_FILENAME_STEM_PATTERN = re.compile('^\\\\s*(?P&lt;coverslip_id&gt;\\\\d+)\\\\s*-\\\\s*(?P&lt;group_type&gt;.+?)\\\\s*$')</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.ROI_COL_PATTERN","title":"<code>ROI_COL_PATTERN = re.compile('^ROI\\\\s*(\\\\d+)\\\\s*\\\\(Average\\\\)$')</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/constants/#calcium_imaging.processing.constants.TIME_COL","title":"<code>TIME_COL = 'Time (ms)'</code>  <code>module-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/","title":"calcium_imaging.processing.extract_coverslip_info_from_filename","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename","title":"<code>calcium_imaging.processing.extract_coverslip_info_from_filename</code>","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.CoverslipInfo","title":"<code>CoverslipInfo</code>","text":"<p>               Bases: <code>NamedTuple</code></p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>class CoverslipInfo(NamedTuple):\n    coverslip_id: int\n    group_type: str\n</code></pre>"},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.CoverslipInfo-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.CoverslipInfo.coverslip_id","title":"<code>coverslip_id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.CoverslipInfo.group_type","title":"<code>group_type: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem","title":"<code>extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo</code>","text":"<p>Extracts coverslip ID and group type from a string of the form ' - ' and returns a CoverslipInfo tuple."},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--parameters","title":"Parameters","text":"<p>filename : str     The filename or label to parse.</p>"},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--returns","title":"Returns","text":"<p>CoverslipInfo     NamedTuple(coverslip_id, group_type)</p>"},{"location":"reference/calcium_imaging/processing/extract_coverslip_info_from_filename/#calcium_imaging.processing.extract_coverslip_info_from_filename.extract_coverslip_info_from_filename_stem--raises","title":"Raises","text":"<p>ValueError     If <code>name</code> doesn\u2019t match the expected pattern.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_coverslip_info_from_filename.py</code> <pre><code>def extract_coverslip_info_from_filename_stem(filename: str) -&gt; CoverslipInfo:\n    \"\"\"\n    Extracts coverslip ID and group type from a string of the form\n    '&lt;coverslip_id&gt; - &lt;group_type&gt;' and returns a CoverslipInfo tuple.\n\n    Parameters\n    ----------\n    filename : str\n        The filename or label to parse.\n\n    Returns\n    -------\n    CoverslipInfo\n        NamedTuple(coverslip_id, group_type)\n\n    Raises\n    ------\n    ValueError\n        If `name` doesn\u2019t match the expected pattern.\n    \"\"\"\n    m = COVERSLIP_FILENAME_STEM_PATTERN.match(filename)\n    if not m:\n        raise ValueError(\n            f\"Invalid format {filename!r}; expected '&lt;coverslip_id&gt; - &lt;group_type&gt;'.\"\n        )\n    return CoverslipInfo(\n        coverslip_id=int(m.group('coverslip_id')),\n        group_type=m.group('group_type').strip()\n    )\n</code></pre>"},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/","title":"calcium_imaging.processing.extract_roi_id_from_col_name","text":""},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name","title":"<code>calcium_imaging.processing.extract_roi_id_from_col_name</code>","text":""},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name","title":"<code>extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]</code>","text":"<p>Extract the ROI ID from a column name of the form 'ROI  (Average)'."},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--parameters","title":"Parameters","text":"<p>col_name : str     The column name to inspect.</p>"},{"location":"reference/calcium_imaging/processing/extract_roi_id_from_col_name/#calcium_imaging.processing.extract_roi_id_from_col_name.extract_roi_id_from_col_name--returns","title":"Returns","text":"<p>Optional[int]     The integer ROI number if the name matches, otherwise None.</p> Source code in <code>src\\calcium_imaging\\processing\\extract_roi_id_from_col_name.py</code> <pre><code>def extract_roi_id_from_col_name(col_name: str) -&gt; Optional[int]:\n    \"\"\"\n    Extract the ROI ID from a column name of the form 'ROI &lt;number&gt; (Average)'.\n\n    Parameters\n    ----------\n    col_name : str\n        The column name to inspect.\n\n    Returns\n    -------\n    Optional[int]\n        The integer ROI number if the name matches, otherwise None.\n    \"\"\"\n    m = ROI_COL_PATTERN.match(col_name)\n    return int(m.group(1)) if m else None\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/","title":"calcium_imaging.processing.preprocessor","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor","title":"<code>calcium_imaging.processing.preprocessor</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor","title":"<code>Preprocessor</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>class Preprocessor:\n    def __init__(\n            self,\n            first_n_points_to_discard: int = 5,\n            smoothing_windows_size: int = 2,\n            time_col_name: str = TIME_COL,\n            background_fluorescence_cols_names: List[str] = BACKGROUND_FLUORESCENCE_ROIS,\n            normalization_sampling_start_frame: int = 1,\n            normalization_sampling_end_frame: int = 35,\n            earliest_onset_frame: int = 50,\n            earliest_baseline_recovery_frame: int = 90,\n            drop_traces_with_corrupted_peak: bool = False,\n            drop_background_fluorescence_cols: bool = True\n    ) -&gt; None:\n        self.first_n_points_to_discard = first_n_points_to_discard\n        self.smoothing_windows_size = smoothing_windows_size\n        self.time_col_name = time_col_name\n        self.background_fluorescence_cols_names = background_fluorescence_cols_names\n        self.normalization_sampling_start_frame = normalization_sampling_start_frame\n        self.normalization_sampling_end_frame = normalization_sampling_end_frame\n        self.earliest_onset_frame = earliest_onset_frame\n        self.earliest_baseline_recovery_frame = earliest_baseline_recovery_frame\n        self.drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak\n        self.drop_background_fluorescence_cols = drop_background_fluorescence_cols\n\n    def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        df = df.copy(deep=True)\n        df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n        df = self.smoothen(df, window_size=self.smoothing_windows_size)\n        df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n        if self.drop_background_fluorescence_cols:\n            df = df.drop(columns=self.background_fluorescence_cols_names)\n        df = self.normalize(\n            df=df,\n            sampling_start_frame=self.normalization_sampling_start_frame,\n            sampling_end_frame=self.normalization_sampling_end_frame\n        )\n        df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n        return df\n\n    @staticmethod\n    def discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n        return df.iloc[n:]\n\n    @staticmethod\n    def smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        return df.rolling(\n            window=window_size,\n            min_periods=1,  # allow smaller windows at edges\n            center=True\n        ).mean()\n\n    @staticmethod\n    def subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n        averaged = df[background_roi_cols].mean(axis=1)\n        result_df = df.subtract(averaged, axis=0)\n        return result_df\n\n    @staticmethod\n    def normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n        \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n        f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n        result_df = df.div(f0, axis=1)\n        return result_df\n\n    @staticmethod\n    def reject_noise(\n            df: pd.DataFrame,\n            *,\n            start_index: int = 35,\n            factor_mean: float = 7.0,\n            factor_peak: float = 2.0,\n            overshoot_thresh: float = 2.0,\n            overshoot_repl: float = 3.0,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Drop columns considered artifactual.\n\n        Criteria (mirrors original MATLAB logic):\n\n        1. Global peak occurs before the rising point  \u2192 remove column.\n        2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n        3. Overshoot spikes above threshold are *corrected* in-place\n           before criteria 1\u20132 are evaluated.\n\n        Returns\n        -------\n        pd.DataFrame\n            Cleaned dataframe with offending columns removed.\n        \"\"\"\n        cleaned = df.copy(deep=True)\n\n        for col in cleaned.columns:\n            s = cleaned[col]\n\n            # step-wise overshoot correction (in-place)\n            cleaned[col] = Preprocessor.correct_overshoot(\n                s,\n                factor_threshold=overshoot_thresh,\n                factor_replacement=overshoot_repl,\n            )\n\n            if Preprocessor.noisy_pre_rise(\n                    cleaned[col], factor_mean, factor_peak, start_index\n            ):\n                cleaned.drop(columns=[col], inplace=True)\n\n        return cleaned\n\n    # ------------------------------------------------------------------\n    def _detect_traces_with_corrupted_peak(self, df: pd.DataFrame, drop: bool = False) -&gt; pd.DataFrame:\n        \"\"\"True if the global maximum is located *before* `start_index`.\"\"\"\n        result_df = df.copy(deep=True)\n        for col, trace in df.items():\n            idx_max = trace.index.values[trace.argmax()]\n            if idx_max &lt; self.earliest_onset_frame:\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n                print(f\"   warning {col}: peak detected before frame {self.earliest_onset_frame}, drop={drop}\")\n            if idx_max &gt; self.earliest_baseline_recovery_frame:\n                print(f\"   warning {col}: peak detected after frame {self.earliest_baseline_recovery_frame}, drop={drop}\")\n                if drop:\n                    result_df = result_df.drop(columns=[col])\n        return result_df\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def correct_overshoot(\n            trace: pd.Series,\n            factor_threshold: float,\n            factor_replacement: float,\n            pre_window: int = 35,\n    ) -&gt; pd.Series:\n        \"\"\"\n        Clamp samples whose value exceeds\n            smooth + factor_threshold * mean_pre_peaks\n        to\n            smooth + factor_replacement * mean_pre_peaks.\n\n        The moving-average of the trace (window=10) is used as the\n        \u201csmooth\u201d estimate.\n        \"\"\"\n        if trace.isna().all():\n            return trace\n\n        smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n        # peaks only in the pre-rise region\n        peaks, _ = find_peaks(trace.iloc[:pre_window])\n        mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n        threshold = smooth + factor_threshold * mean_pre_peaks\n        replacement = smooth + factor_replacement * mean_pre_peaks\n\n        corrected = trace.where(trace &lt;= threshold, replacement)\n        return corrected\n\n    # ------------------------------------------------------------------\n    @staticmethod\n    def noisy_pre_rise(\n            trace: pd.Series,\n            factor_mean: float,\n            factor_peak: float,\n            start_index: int = 35,\n    ) -&gt; bool:\n        \"\"\"\n        Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n        Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n        Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n        \"\"\"\n        if trace.isna().all():\n            return True\n\n        pre_segment = trace.iloc[:start_index]\n        peaks, _ = find_peaks(pre_segment)\n\n        if peaks.size == 0:\n            return False  # no peaks \u21d2 not noisy by this definition\n\n        peaks_vals = pre_segment.iloc[peaks]\n        global_max = trace.max()\n\n        condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n        condition2 = peaks_vals.max() * factor_peak &gt; global_max\n        return condition1 or condition2\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor-attributes","title":"Attributes","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.background_fluorescence_cols_names","title":"<code>background_fluorescence_cols_names = background_fluorescence_cols_names</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.drop_background_fluorescence_cols","title":"<code>drop_background_fluorescence_cols = drop_background_fluorescence_cols</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.drop_traces_with_corrupted_peak","title":"<code>drop_traces_with_corrupted_peak = drop_traces_with_corrupted_peak</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.earliest_baseline_recovery_frame","title":"<code>earliest_baseline_recovery_frame = earliest_baseline_recovery_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.earliest_onset_frame","title":"<code>earliest_onset_frame = earliest_onset_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.first_n_points_to_discard","title":"<code>first_n_points_to_discard = first_n_points_to_discard</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.normalization_sampling_end_frame","title":"<code>normalization_sampling_end_frame = normalization_sampling_end_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.normalization_sampling_start_frame","title":"<code>normalization_sampling_start_frame = normalization_sampling_start_frame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.smoothing_windows_size","title":"<code>smoothing_windows_size = smoothing_windows_size</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.time_col_name","title":"<code>time_col_name = time_col_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.correct_overshoot","title":"<code>correct_overshoot(trace: pd.Series, factor_threshold: float, factor_replacement: float, pre_window: int = 35) -&gt; pd.Series</code>  <code>staticmethod</code>","text":"<p>Clamp samples whose value exceeds     smooth + factor_threshold * mean_pre_peaks to     smooth + factor_replacement * mean_pre_peaks.</p> <p>The moving-average of the trace (window=10) is used as the \u201csmooth\u201d estimate.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef correct_overshoot(\n        trace: pd.Series,\n        factor_threshold: float,\n        factor_replacement: float,\n        pre_window: int = 35,\n) -&gt; pd.Series:\n    \"\"\"\n    Clamp samples whose value exceeds\n        smooth + factor_threshold * mean_pre_peaks\n    to\n        smooth + factor_replacement * mean_pre_peaks.\n\n    The moving-average of the trace (window=10) is used as the\n    \u201csmooth\u201d estimate.\n    \"\"\"\n    if trace.isna().all():\n        return trace\n\n    smooth = trace.rolling(window=10, center=True, min_periods=1).mean()\n    # peaks only in the pre-rise region\n    peaks, _ = find_peaks(trace.iloc[:pre_window])\n    mean_pre_peaks = trace.iloc[peaks].mean() if peaks.size else 0.0\n\n    threshold = smooth + factor_threshold * mean_pre_peaks\n    replacement = smooth + factor_replacement * mean_pre_peaks\n\n    corrected = trace.where(trace &lt;= threshold, replacement)\n    return corrected\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.discard_first_n_points","title":"<code>discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef discard_first_n_points(df: pd.DataFrame, n: int) -&gt; pd.DataFrame:\n    return df.iloc[n:]\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.noisy_pre_rise","title":"<code>noisy_pre_rise(trace: pd.Series, factor_mean: float, factor_peak: float, start_index: int = 35) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Returns True if the pre-rise segment is noisy per MATLAB rules.</p> <p>Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef noisy_pre_rise(\n        trace: pd.Series,\n        factor_mean: float,\n        factor_peak: float,\n        start_index: int = 35,\n) -&gt; bool:\n    \"\"\"\n    Returns *True* if the pre-rise segment is noisy per MATLAB rules.\n\n    Rule 1 \u2013 mean(pre-segment peaks) \u00b7 factor_mean  &gt; global_max\n    Rule 2 \u2013 max(pre-segment peaks)  \u00b7 factor_peak  &gt; global_max\n    \"\"\"\n    if trace.isna().all():\n        return True\n\n    pre_segment = trace.iloc[:start_index]\n    peaks, _ = find_peaks(pre_segment)\n\n    if peaks.size == 0:\n        return False  # no peaks \u21d2 not noisy by this definition\n\n    peaks_vals = pre_segment.iloc[peaks]\n    global_max = trace.max()\n\n    condition1 = peaks_vals.mean() * factor_mean &gt; global_max\n    condition2 = peaks_vals.max() * factor_peak &gt; global_max\n    return condition1 or condition2\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.normalize","title":"<code>normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef normalize(df: pd.DataFrame, sampling_start_frame: int = 1, sampling_end_frame: int = 35) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    f0 = df.iloc[sampling_start_frame:sampling_end_frame].mean(axis=0)  # baseline fluorescence\n    result_df = df.div(f0, axis=1)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.preprocess","title":"<code>preprocess(df: pd.DataFrame) -&gt; pd.DataFrame</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>def preprocess(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n    df = df.copy(deep=True)\n    df = self.discard_first_n_points(df, n=self.first_n_points_to_discard)\n    df = self.smoothen(df, window_size=self.smoothing_windows_size)\n    df = self.subtract_baseline_fluorescence(df, self.background_fluorescence_cols_names)\n    if self.drop_background_fluorescence_cols:\n        df = df.drop(columns=self.background_fluorescence_cols_names)\n    df = self.normalize(\n        df=df,\n        sampling_start_frame=self.normalization_sampling_start_frame,\n        sampling_end_frame=self.normalization_sampling_end_frame\n    )\n    df = self._detect_traces_with_corrupted_peak(df, drop=self.drop_traces_with_corrupted_peak)\n    return df\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.reject_noise","title":"<code>reject_noise(df: pd.DataFrame, *, start_index: int = 35, factor_mean: float = 7.0, factor_peak: float = 2.0, overshoot_thresh: float = 2.0, overshoot_repl: float = 3.0) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Drop columns considered artifactual.</p> <p>Criteria (mirrors original MATLAB logic):</p> <ol> <li>Global peak occurs before the rising point  \u2192 remove column.</li> <li>Pre-rise segment too noisy (see <code>noisy_pre_rise</code>)            \u2192 remove.</li> <li>Overshoot spikes above threshold are corrected in-place    before criteria 1\u20132 are evaluated.</li> </ol>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.reject_noise--returns","title":"Returns","text":"<p>pd.DataFrame     Cleaned dataframe with offending columns removed.</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef reject_noise(\n        df: pd.DataFrame,\n        *,\n        start_index: int = 35,\n        factor_mean: float = 7.0,\n        factor_peak: float = 2.0,\n        overshoot_thresh: float = 2.0,\n        overshoot_repl: float = 3.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Drop columns considered artifactual.\n\n    Criteria (mirrors original MATLAB logic):\n\n    1. Global peak occurs before the rising point  \u2192 remove column.\n    2. Pre-rise segment too noisy (see `noisy_pre_rise`)            \u2192 remove.\n    3. Overshoot spikes above threshold are *corrected* in-place\n       before criteria 1\u20132 are evaluated.\n\n    Returns\n    -------\n    pd.DataFrame\n        Cleaned dataframe with offending columns removed.\n    \"\"\"\n    cleaned = df.copy(deep=True)\n\n    for col in cleaned.columns:\n        s = cleaned[col]\n\n        # step-wise overshoot correction (in-place)\n        cleaned[col] = Preprocessor.correct_overshoot(\n            s,\n            factor_threshold=overshoot_thresh,\n            factor_replacement=overshoot_repl,\n        )\n\n        if Preprocessor.noisy_pre_rise(\n                cleaned[col], factor_mean, factor_peak, start_index\n        ):\n            cleaned.drop(columns=[col], inplace=True)\n\n    return cleaned\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.smoothen","title":"<code>smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"<p>Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols</p> Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef smoothen(df: pd.DataFrame, window_size: int = 2) -&gt; pd.DataFrame:\n    \"\"\"Assuming df includes only cell ROIs (no dead / fluorescence background) ROIs or time cols\"\"\"\n    return df.rolling(\n        window=window_size,\n        min_periods=1,  # allow smaller windows at edges\n        center=True\n    ).mean()\n</code></pre>"},{"location":"reference/calcium_imaging/processing/preprocessor/#calcium_imaging.processing.preprocessor.Preprocessor.subtract_baseline_fluorescence","title":"<code>subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame</code>  <code>staticmethod</code>","text":"Source code in <code>src\\calcium_imaging\\processing\\preprocessor.py</code> <pre><code>@staticmethod\ndef subtract_baseline_fluorescence(df: pd.DataFrame, background_roi_cols: List[str]) -&gt; pd.DataFrame:\n    averaged = df[background_roi_cols].mean(axis=1)\n    result_df = df.subtract(averaged, axis=0)\n    return result_df\n</code></pre>"},{"location":"reference/calcium_imaging/ui/","title":"calcium_imaging.ui","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui","title":"<code>calcium_imaging.ui</code>","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_bool_input","title":"<code>get_bool_input</code>","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_bool_input-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_bool_input.get_bool_input","title":"<code>get_bool_input(prompt: str) -&gt; bool</code>","text":"Source code in <code>src\\calcium_imaging\\ui\\get_bool_input.py</code> <pre><code>def get_bool_input(prompt: str) -&gt; bool:\n    true_values = {'y', 'yes', 'true', '1'}\n    false_values = {'n', 'no', 'false', '0'}\n\n    while True:\n        response = input(prompt).strip().lower()\n        if response in true_values:\n            return True\n        elif response in false_values:\n            return False\n        else:\n            print(\"Invalid input. Please enter a value like: y, yes, true, 1, n, no, false, or 0.\")\n</code></pre>"},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_int_input","title":"<code>get_int_input</code>","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_int_input-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/ui/#calcium_imaging.ui.get_int_input.get_int_input","title":"<code>get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None</code>","text":"Source code in <code>src\\calcium_imaging\\ui\\get_int_input.py</code> <pre><code>def get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None:\n    while True:\n        response = input(prompt).strip().lower()\n\n        if allow_none and (response == \"\" or response in {'none', 'skip'}):\n            return None\n\n        if response.isdigit() or (response.startswith('-') and response[1:].isdigit()):\n            value = int(response)\n            if (min_value is not None and value &lt; min_value) or \\\n               (max_value is not None and value &gt; max_value):\n                print(f\"Please enter an integer between {min_value} and {max_value}, or press Enter to skip.\")\n            else:\n                return value\n        else:\n            print(\"Invalid input. Please enter an integer\" + (\", or press Enter to skip.\" if allow_none else \".\"))\n</code></pre>"},{"location":"reference/calcium_imaging/ui/get_bool_input/","title":"calcium_imaging.ui.get_bool_input","text":""},{"location":"reference/calcium_imaging/ui/get_bool_input/#calcium_imaging.ui.get_bool_input","title":"<code>calcium_imaging.ui.get_bool_input</code>","text":""},{"location":"reference/calcium_imaging/ui/get_bool_input/#calcium_imaging.ui.get_bool_input-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/ui/get_bool_input/#calcium_imaging.ui.get_bool_input.get_bool_input","title":"<code>get_bool_input(prompt: str) -&gt; bool</code>","text":"Source code in <code>src\\calcium_imaging\\ui\\get_bool_input.py</code> <pre><code>def get_bool_input(prompt: str) -&gt; bool:\n    true_values = {'y', 'yes', 'true', '1'}\n    false_values = {'n', 'no', 'false', '0'}\n\n    while True:\n        response = input(prompt).strip().lower()\n        if response in true_values:\n            return True\n        elif response in false_values:\n            return False\n        else:\n            print(\"Invalid input. Please enter a value like: y, yes, true, 1, n, no, false, or 0.\")\n</code></pre>"},{"location":"reference/calcium_imaging/ui/get_int_input/","title":"calcium_imaging.ui.get_int_input","text":""},{"location":"reference/calcium_imaging/ui/get_int_input/#calcium_imaging.ui.get_int_input","title":"<code>calcium_imaging.ui.get_int_input</code>","text":""},{"location":"reference/calcium_imaging/ui/get_int_input/#calcium_imaging.ui.get_int_input-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/ui/get_int_input/#calcium_imaging.ui.get_int_input.get_int_input","title":"<code>get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None</code>","text":"Source code in <code>src\\calcium_imaging\\ui\\get_int_input.py</code> <pre><code>def get_int_input(prompt: str, min_value: int = None, max_value: int = None, allow_none: bool = True) -&gt; int | None:\n    while True:\n        response = input(prompt).strip().lower()\n\n        if allow_none and (response == \"\" or response in {'none', 'skip'}):\n            return None\n\n        if response.isdigit() or (response.startswith('-') and response[1:].isdigit()):\n            value = int(response)\n            if (min_value is not None and value &lt; min_value) or \\\n               (max_value is not None and value &gt; max_value):\n                print(f\"Please enter an integer between {min_value} and {max_value}, or press Enter to skip.\")\n            else:\n                return value\n        else:\n            print(\"Invalid input. Please enter an integer\" + (\", or press Enter to skip.\" if allow_none else \".\"))\n</code></pre>"},{"location":"reference/calcium_imaging/viz/","title":"calcium_imaging.viz","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz","title":"<code>calcium_imaging.viz</code>","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz-modules","title":"Modules","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.create_trace_figure","title":"<code>create_trace_figure</code>","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.create_trace_figure-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.create_trace_figure-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.create_trace_figure.create_traces_figure","title":"<code>create_traces_figure(main_trace: pd.Series, main_trace_peak_index: Optional[int] = None, main_trace_onset_index: Optional[int] = None, main_trace_baseline_return_index: Optional[int] = None, additional_traces: Optional[Iterable[pd.Series]] = None, additional_traces_peak_indexes: Optional[List[int]] = None, additional_traces_onset_indexes: Optional[List[int]] = None, additional_traces_baseline_return_indexes: Optional[List[int]] = None, title: Optional[str] = None, xaxis_title: Optional[str] = None, yaxis_title: Optional[str] = None, eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None, influx_linear_coefficients: Optional[RegressionCoefficients1D] = None, yaxis_range: Optional[Tuple[float, float]] = (0.5, 2), traces_color: Optional[str] = 'blue') -&gt; go.Figure</code>","text":"Source code in <code>src\\calcium_imaging\\viz\\create_trace_figure.py</code> <pre><code>def create_traces_figure(\n        main_trace: pd.Series,\n        main_trace_peak_index: Optional[int] = None,\n        main_trace_onset_index: Optional[int] = None,\n        main_trace_baseline_return_index: Optional[int] = None,\n        additional_traces: Optional[Iterable[pd.Series]] = None,\n        additional_traces_peak_indexes: Optional[List[int]] = None,\n        additional_traces_onset_indexes: Optional[List[int]] = None,\n        additional_traces_baseline_return_indexes: Optional[List[int]] = None,\n        title: Optional[str] = None,\n        xaxis_title: Optional[str] = None,\n        yaxis_title: Optional[str] = None,\n        eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        influx_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        yaxis_range: Optional[Tuple[float, float]] = (0.5, 2),\n        traces_color: Optional[str] = \"blue\"\n) -&gt; go.Figure:\n    # --- base trace ---\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Scatter(\n            x=main_trace.index.values,\n            y=main_trace.values,\n            mode=\"lines\",\n            name=main_trace.name,\n            line=dict(color=traces_color),\n            legendgroup=main_trace.name,\n        )\n    )\n\n    if main_trace_peak_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_peak_index],\n                y=[main_trace[main_trace_peak_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                name=f\"peak {main_trace.name}\",\n                opacity=0.5,\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_onset_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_onset_index],\n                y=[main_trace[main_trace_onset_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"onset {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_baseline_return_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_baseline_return_index],\n                y=[main_trace[main_trace_baseline_return_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"baseline return {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if additional_traces is not None:\n        for i, trace in enumerate(additional_traces):\n            fig.add_trace(\n                go.Scatter(\n                    x=trace.index.values,\n                    y=trace.values,\n                    mode=\"lines\",\n                    name=trace.name,\n                    opacity=0.15,\n                    line=dict(color=traces_color),\n                    legendgroup=trace.name,\n                )\n            )\n            if additional_traces_peak_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_peak_indexes[i]],\n                        y=[trace[additional_traces_peak_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                        name=f\"peak {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_onset_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_onset_indexes[i]],\n                        y=[trace[additional_traces_onset_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                        name=f\"onset {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_baseline_return_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_baseline_return_indexes[i]],\n                        y=[trace[additional_traces_baseline_return_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                        name=f\"baseline return {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n\n    if eflux_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = eflux_linear_coefficients.slope * x_vals + eflux_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"eflux={eflux_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    if influx_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = influx_linear_coefficients.slope * x_vals + influx_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"influx={influx_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    fig.update_layout(\n        title=title,\n        xaxis_title=xaxis_title,\n        yaxis_title=yaxis_title,\n        yaxis_range=yaxis_range if yaxis_range[1] &gt; main_trace.max() else (yaxis_range[0], main_trace.max() + 0.1),\n        template=\"plotly_white\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.plotly_color_iterator","title":"<code>plotly_color_iterator</code>","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.plotly_color_iterator-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/viz/#calcium_imaging.viz.plotly_color_iterator.get_n_colors_from_palette","title":"<code>get_n_colors_from_palette(n: int, palette_name: str = 'Plotly') -&gt; List[str]</code>","text":"Source code in <code>src\\calcium_imaging\\viz\\plotly_color_iterator.py</code> <pre><code>def get_n_colors_from_palette(n: int, palette_name: str = \"Plotly\") -&gt; List[str]:\n    color_iter = _get_color_iterator(palette_name)\n    return [next(color_iter) for _ in range(n)]\n</code></pre>"},{"location":"reference/calcium_imaging/viz/create_trace_figure/","title":"calcium_imaging.viz.create_trace_figure","text":""},{"location":"reference/calcium_imaging/viz/create_trace_figure/#calcium_imaging.viz.create_trace_figure","title":"<code>calcium_imaging.viz.create_trace_figure</code>","text":""},{"location":"reference/calcium_imaging/viz/create_trace_figure/#calcium_imaging.viz.create_trace_figure-classes","title":"Classes","text":""},{"location":"reference/calcium_imaging/viz/create_trace_figure/#calcium_imaging.viz.create_trace_figure-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/viz/create_trace_figure/#calcium_imaging.viz.create_trace_figure.create_traces_figure","title":"<code>create_traces_figure(main_trace: pd.Series, main_trace_peak_index: Optional[int] = None, main_trace_onset_index: Optional[int] = None, main_trace_baseline_return_index: Optional[int] = None, additional_traces: Optional[Iterable[pd.Series]] = None, additional_traces_peak_indexes: Optional[List[int]] = None, additional_traces_onset_indexes: Optional[List[int]] = None, additional_traces_baseline_return_indexes: Optional[List[int]] = None, title: Optional[str] = None, xaxis_title: Optional[str] = None, yaxis_title: Optional[str] = None, eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None, influx_linear_coefficients: Optional[RegressionCoefficients1D] = None, yaxis_range: Optional[Tuple[float, float]] = (0.5, 2), traces_color: Optional[str] = 'blue') -&gt; go.Figure</code>","text":"Source code in <code>src\\calcium_imaging\\viz\\create_trace_figure.py</code> <pre><code>def create_traces_figure(\n        main_trace: pd.Series,\n        main_trace_peak_index: Optional[int] = None,\n        main_trace_onset_index: Optional[int] = None,\n        main_trace_baseline_return_index: Optional[int] = None,\n        additional_traces: Optional[Iterable[pd.Series]] = None,\n        additional_traces_peak_indexes: Optional[List[int]] = None,\n        additional_traces_onset_indexes: Optional[List[int]] = None,\n        additional_traces_baseline_return_indexes: Optional[List[int]] = None,\n        title: Optional[str] = None,\n        xaxis_title: Optional[str] = None,\n        yaxis_title: Optional[str] = None,\n        eflux_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        influx_linear_coefficients: Optional[RegressionCoefficients1D] = None,\n        yaxis_range: Optional[Tuple[float, float]] = (0.5, 2),\n        traces_color: Optional[str] = \"blue\"\n) -&gt; go.Figure:\n    # --- base trace ---\n    fig = go.Figure()\n\n    fig.add_trace(\n        go.Scatter(\n            x=main_trace.index.values,\n            y=main_trace.values,\n            mode=\"lines\",\n            name=main_trace.name,\n            line=dict(color=traces_color),\n            legendgroup=main_trace.name,\n        )\n    )\n\n    if main_trace_peak_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_peak_index],\n                y=[main_trace[main_trace_peak_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                name=f\"peak {main_trace.name}\",\n                opacity=0.5,\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_onset_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_onset_index],\n                y=[main_trace[main_trace_onset_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"onset {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if main_trace_baseline_return_index is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=[main_trace_baseline_return_index],\n                y=[main_trace[main_trace_baseline_return_index]],\n                mode=\"markers\",\n                marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                opacity=0.5,\n                name=f\"baseline return {main_trace.name}\",\n                legendgroup=main_trace.name,\n                showlegend=False\n            )\n        )\n\n    if additional_traces is not None:\n        for i, trace in enumerate(additional_traces):\n            fig.add_trace(\n                go.Scatter(\n                    x=trace.index.values,\n                    y=trace.values,\n                    mode=\"lines\",\n                    name=trace.name,\n                    opacity=0.15,\n                    line=dict(color=traces_color),\n                    legendgroup=trace.name,\n                )\n            )\n            if additional_traces_peak_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_peak_indexes[i]],\n                        y=[trace[additional_traces_peak_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"red\", symbol=\"circle\"),\n                        name=f\"peak {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_onset_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_onset_indexes[i]],\n                        y=[trace[additional_traces_onset_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"green\", symbol=\"circle\"),\n                        name=f\"onset {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n            if additional_traces_baseline_return_indexes is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=[additional_traces_baseline_return_indexes[i]],\n                        y=[trace[additional_traces_baseline_return_indexes[i]]],\n                        mode=\"markers\",\n                        marker=dict(size=8, color=\"orange\", symbol=\"circle\"),\n                        name=f\"baseline return {trace.name}\",\n                        legendgroup=trace.name,\n                        showlegend=False,\n                        opacity=0.1,\n                    )\n                )\n\n    if eflux_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = eflux_linear_coefficients.slope * x_vals + eflux_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"eflux={eflux_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    if influx_linear_coefficients is not None:\n        x_vals = main_trace.index.values\n        y_vals = influx_linear_coefficients.slope * x_vals + influx_linear_coefficients.intercept\n        fig.add_trace(\n            go.Scatter(\n                x=x_vals,\n                y=y_vals,\n                mode=\"lines\",\n                line=dict(dash='dash', color='black'),\n                name=f\"influx={influx_linear_coefficients.slope:.4f}\"\n            )\n        )\n\n    fig.update_layout(\n        title=title,\n        xaxis_title=xaxis_title,\n        yaxis_title=yaxis_title,\n        yaxis_range=yaxis_range if yaxis_range[1] &gt; main_trace.max() else (yaxis_range[0], main_trace.max() + 0.1),\n        template=\"plotly_white\",\n        xaxis=dict(showgrid=False),\n        yaxis=dict(showgrid=False),\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.05,\n            font=dict(size=10),\n            traceorder=\"normal\",\n        ),\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/calcium_imaging/viz/plotly_color_iterator/","title":"calcium_imaging.viz.plotly_color_iterator","text":""},{"location":"reference/calcium_imaging/viz/plotly_color_iterator/#calcium_imaging.viz.plotly_color_iterator","title":"<code>calcium_imaging.viz.plotly_color_iterator</code>","text":""},{"location":"reference/calcium_imaging/viz/plotly_color_iterator/#calcium_imaging.viz.plotly_color_iterator-functions","title":"Functions","text":""},{"location":"reference/calcium_imaging/viz/plotly_color_iterator/#calcium_imaging.viz.plotly_color_iterator.get_n_colors_from_palette","title":"<code>get_n_colors_from_palette(n: int, palette_name: str = 'Plotly') -&gt; List[str]</code>","text":"Source code in <code>src\\calcium_imaging\\viz\\plotly_color_iterator.py</code> <pre><code>def get_n_colors_from_palette(n: int, palette_name: str = \"Plotly\") -&gt; List[str]:\n    color_iter = _get_color_iterator(palette_name)\n    return [next(color_iter) for _ in range(n)]\n</code></pre>"}]}